//==- HexagonInstrInfo.td - Target Description for Hexagon -*- tablegen -*-===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
//
// This file describes the Hexagon instructions in TableGen format.
//
//===----------------------------------------------------------------------===//

include "HexagonInstrFormats.td"
include "HexagonOperands.td"

// Pattern fragment that combines the value type and the register class
// into a single parameter.
// The pat frags in the definitions below need to have a named register,
// otherwise i32 will be assumed regardless of the register class. The
// name of the register does not matter.
def I1  : PatLeaf<(i1 PredRegs:$R)>;
def I32 : PatLeaf<(i32 IntRegs:$R)>;
def I64 : PatLeaf<(i64 DoubleRegs:$R)>;
def F32 : PatLeaf<(f32 IntRegs:$R)>;
def F64 : PatLeaf<(f64 DoubleRegs:$R)>;

// Pattern fragments to extract the low and high subregisters from a
// 64-bit value.
def LoReg: OutPatFrag<(ops node:$Rs),
                      (EXTRACT_SUBREG (i64 $Rs), subreg_loreg)>;

//===----------------------------------------------------------------------===//

//===----------------------------------------------------------------------===//
// Compare
//===----------------------------------------------------------------------===//
let hasSideEffects = 0, isCompare = 1, InputType = "imm", isExtendable = 1,
    opExtendable = 2 in
class T_CMP <string mnemonic, bits<2> MajOp, bit isNot, Operand ImmOp>
  : ALU32Inst <(outs PredRegs:$dst),
               (ins IntRegs:$src1, ImmOp:$src2),
  "$dst = "#!if(isNot, "!","")#mnemonic#"($src1, #$src2)",
  [], "",ALU32_2op_tc_2early_SLOT0123 >, ImmRegRel {
    bits<2> dst;
    bits<5> src1;
    bits<10> src2;
    let CextOpcode = mnemonic;
    let opExtentBits  = !if(!eq(mnemonic, "cmp.gtu"), 9, 10);
    let isExtentSigned = !if(!eq(mnemonic, "cmp.gtu"), 0, 1);

    let IClass = 0b0111;

    let Inst{27-24} = 0b0101;
    let Inst{23-22} = MajOp;
    let Inst{21}    = !if(!eq(mnemonic, "cmp.gtu"), 0, src2{9});
    let Inst{20-16} = src1;
    let Inst{13-5}  = src2{8-0};
    let Inst{4}     = isNot;
    let Inst{3-2}   = 0b00;
    let Inst{1-0}   = dst;
  }

def C2_cmpeqi   : T_CMP <"cmp.eq",  0b00, 0, s10Ext>;
def C2_cmpgti   : T_CMP <"cmp.gt",  0b01, 0, s10Ext>;
def C2_cmpgtui  : T_CMP <"cmp.gtu", 0b10, 0, u9Ext>;

class T_CMP_pat <InstHexagon MI, PatFrag OpNode, PatLeaf ImmPred>
  : Pat<(i1 (OpNode (i32 IntRegs:$src1), ImmPred:$src2)),
        (MI IntRegs:$src1, ImmPred:$src2)>;

def : T_CMP_pat <C2_cmpeqi,  seteq,  s10ImmPred>;
def : T_CMP_pat <C2_cmpgti,  setgt,  s10ImmPred>;
def : T_CMP_pat <C2_cmpgtui, setugt, u9ImmPred>;

//===----------------------------------------------------------------------===//
// ALU32/ALU +
//===----------------------------------------------------------------------===//
def SDTHexagonI64I32I32 : SDTypeProfile<1, 2,
  [SDTCisVT<0, i64>, SDTCisVT<1, i32>, SDTCisSameAs<1, 2>]>;

def HexagonCOMBINE : SDNode<"HexagonISD::COMBINE", SDTHexagonI64I32I32>;

let hasSideEffects = 0, hasNewValue = 1, InputType = "reg" in
class T_ALU32_3op<string mnemonic, bits<3> MajOp, bits<3> MinOp, bit OpsRev,
                  bit IsComm>
  : ALU32_rr<(outs IntRegs:$Rd), (ins IntRegs:$Rs, IntRegs:$Rt),
             "$Rd = "#mnemonic#"($Rs, $Rt)",
             [], "", ALU32_3op_tc_1_SLOT0123>, ImmRegRel, PredRel {
  let isCommutable = IsComm;
  let BaseOpcode = mnemonic#_rr;
  let CextOpcode = mnemonic;

  bits<5> Rs;
  bits<5> Rt;
  bits<5> Rd;

  let IClass = 0b1111;
  let Inst{27} = 0b0;
  let Inst{26-24} = MajOp;
  let Inst{23-21} = MinOp;
  let Inst{20-16} = !if(OpsRev,Rt,Rs);
  let Inst{12-8} = !if(OpsRev,Rs,Rt);
  let Inst{4-0} = Rd;
}

let hasSideEffects = 0, hasNewValue = 1 in
class T_ALU32_3op_pred<string mnemonic, bits<3> MajOp, bits<3> MinOp,
                       bit OpsRev, bit PredNot, bit PredNew>
  : ALU32_rr<(outs IntRegs:$Rd), (ins PredRegs:$Pu, IntRegs:$Rs, IntRegs:$Rt),
             "if ("#!if(PredNot,"!","")#"$Pu"#!if(PredNew,".new","")#") "#
             "$Rd = "#mnemonic#"($Rs, $Rt)",
             [], "", ALU32_3op_tc_1_SLOT0123>, ImmRegRel, PredNewRel {
  let isPredicated = 1;
  let isPredicatedFalse = PredNot;
  let isPredicatedNew = PredNew;
  let BaseOpcode = mnemonic#_rr;
  let CextOpcode = mnemonic;

  bits<2> Pu;
  bits<5> Rs;
  bits<5> Rt;
  bits<5> Rd;

  let IClass = 0b1111;
  let Inst{27} = 0b1;
  let Inst{26-24} = MajOp;
  let Inst{23-21} = MinOp;
  let Inst{20-16} = !if(OpsRev,Rt,Rs);
  let Inst{13} = PredNew;
  let Inst{12-8} = !if(OpsRev,Rs,Rt);
  let Inst{7} = PredNot;
  let Inst{6-5} = Pu;
  let Inst{4-0} = Rd;
}

class T_ALU32_combineh<string Op1, string Op2, bits<3> MajOp, bits<3> MinOp,
                      bit OpsRev>
  : T_ALU32_3op<"", MajOp, MinOp, OpsRev, 0> {
  let AsmString = "$Rd = combine($Rs"#Op1#", $Rt"#Op2#")";
}

let isCodeGenOnly = 0 in {
def A2_combine_hh : T_ALU32_combineh<".h", ".h", 0b011, 0b100, 1>;
def A2_combine_hl : T_ALU32_combineh<".h", ".l", 0b011, 0b101, 1>;
def A2_combine_lh : T_ALU32_combineh<".l", ".h", 0b011, 0b110, 1>;
def A2_combine_ll : T_ALU32_combineh<".l", ".l", 0b011, 0b111, 1>;
}

class T_ALU32_3op_sfx<string mnemonic, string suffix, bits<3> MajOp,
                      bits<3> MinOp, bit OpsRev, bit IsComm>
  : T_ALU32_3op<"", MajOp, MinOp, OpsRev, IsComm> {
  let AsmString = "$Rd = "#mnemonic#"($Rs, $Rt)"#suffix;
}

let Defs = [USR_OVF], Itinerary = ALU32_3op_tc_2_SLOT0123, 
    isCodeGenOnly = 0 in {
  def A2_addsat   : T_ALU32_3op_sfx<"add",    ":sat", 0b110, 0b010, 0, 1>;
  def A2_subsat   : T_ALU32_3op_sfx<"sub",    ":sat", 0b110, 0b110, 1, 0>;
}

multiclass T_ALU32_3op_p<string mnemonic, bits<3> MajOp, bits<3> MinOp,
                         bit OpsRev> {
  def t    : T_ALU32_3op_pred<mnemonic, MajOp, MinOp, OpsRev, 0, 0>;
  def f    : T_ALU32_3op_pred<mnemonic, MajOp, MinOp, OpsRev, 1, 0>;
  def tnew : T_ALU32_3op_pred<mnemonic, MajOp, MinOp, OpsRev, 0, 1>;
  def fnew : T_ALU32_3op_pred<mnemonic, MajOp, MinOp, OpsRev, 1, 1>;
}

multiclass T_ALU32_3op_A2<string mnemonic, bits<3> MajOp, bits<3> MinOp,
                          bit OpsRev, bit IsComm> {
  let isPredicable = 1 in
  def  A2_#NAME  : T_ALU32_3op  <mnemonic, MajOp, MinOp, OpsRev, IsComm>;
  defm A2_p#NAME : T_ALU32_3op_p<mnemonic, MajOp, MinOp, OpsRev>;
}

let isCodeGenOnly = 0 in {
defm add : T_ALU32_3op_A2<"add", 0b011, 0b000, 0, 1>;
defm and : T_ALU32_3op_A2<"and", 0b001, 0b000, 0, 1>;
defm or  : T_ALU32_3op_A2<"or",  0b001, 0b001, 0, 1>;
defm sub : T_ALU32_3op_A2<"sub", 0b011, 0b001, 1, 0>;
defm xor : T_ALU32_3op_A2<"xor", 0b001, 0b011, 0, 1>;
}

// Pats for instruction selection.
class BinOp32_pat<SDNode Op, InstHexagon MI, ValueType ResT>
  : Pat<(ResT (Op (i32 IntRegs:$Rs), (i32 IntRegs:$Rt))),
        (ResT (MI IntRegs:$Rs, IntRegs:$Rt))>;

def: BinOp32_pat<add, A2_add, i32>;
def: BinOp32_pat<and, A2_and, i32>;
def: BinOp32_pat<or,  A2_or,  i32>;
def: BinOp32_pat<sub, A2_sub, i32>;
def: BinOp32_pat<xor, A2_xor, i32>;

// A few special cases producing register pairs:
let OutOperandList = (outs DoubleRegs:$Rd), hasNewValue = 0,
    isCodeGenOnly = 0 in {
  def S2_packhl    : T_ALU32_3op  <"packhl",  0b101, 0b100, 0, 0>;

  let isPredicable = 1 in
    def A2_combinew  : T_ALU32_3op  <"combine", 0b101, 0b000, 0, 0>;

  // Conditional combinew uses "newt/f" instead of "t/fnew".
  def C2_ccombinewt    : T_ALU32_3op_pred<"combine", 0b101, 0b000, 0, 0, 0>;
  def C2_ccombinewf    : T_ALU32_3op_pred<"combine", 0b101, 0b000, 0, 1, 0>;
  def C2_ccombinewnewt : T_ALU32_3op_pred<"combine", 0b101, 0b000, 0, 0, 1>;
  def C2_ccombinewnewf : T_ALU32_3op_pred<"combine", 0b101, 0b000, 0, 1, 1>;
}

let hasSideEffects = 0, hasNewValue = 1, isCompare = 1, InputType = "reg"  in
class T_ALU32_3op_cmp<string mnemonic, bits<2> MinOp, bit IsNeg, bit IsComm>
  : ALU32_rr<(outs PredRegs:$Pd), (ins IntRegs:$Rs, IntRegs:$Rt),
             "$Pd = "#mnemonic#"($Rs, $Rt)",
             [], "", ALU32_3op_tc_1_SLOT0123>, ImmRegRel {
  let CextOpcode = mnemonic;
  let isCommutable = IsComm;
  bits<5> Rs;
  bits<5> Rt;
  bits<2> Pd;

  let IClass = 0b1111;
  let Inst{27-24} = 0b0010;
  let Inst{22-21} = MinOp;
  let Inst{20-16} = Rs;
  let Inst{12-8} = Rt;
  let Inst{4} = IsNeg;
  let Inst{3-2} = 0b00;
  let Inst{1-0} = Pd;
}

let Itinerary = ALU32_3op_tc_2early_SLOT0123, isCodeGenOnly = 0 in {
  def C2_cmpeq   : T_ALU32_3op_cmp< "cmp.eq",  0b00, 0, 1>;
  def C2_cmpgt   : T_ALU32_3op_cmp< "cmp.gt",  0b10, 0, 0>;
  def C2_cmpgtu  : T_ALU32_3op_cmp< "cmp.gtu", 0b11, 0, 0>;
}

// Patfrag to convert the usual comparison patfrags (e.g. setlt) to ones
// that reverse the order of the operands.
class RevCmp<PatFrag F> : PatFrag<(ops node:$rhs, node:$lhs), F.Fragment>;

// Pats for compares. They use PatFrags as operands, not SDNodes,
// since seteq/setgt/etc. are defined as ParFrags.
class T_cmp32_rr_pat<InstHexagon MI, PatFrag Op, ValueType VT>
  : Pat<(VT (Op (i32 IntRegs:$Rs), (i32 IntRegs:$Rt))),
        (VT (MI IntRegs:$Rs, IntRegs:$Rt))>;

def: T_cmp32_rr_pat<C2_cmpeq,  seteq, i1>;
def: T_cmp32_rr_pat<C2_cmpgt,  setgt, i1>;
def: T_cmp32_rr_pat<C2_cmpgtu, setugt, i1>;

def: T_cmp32_rr_pat<C2_cmpgt,  RevCmp<setlt>,  i1>;
def: T_cmp32_rr_pat<C2_cmpgtu, RevCmp<setult>, i1>;

let CextOpcode = "MUX", InputType = "reg", hasNewValue = 1,
  isCodeGenOnly = 0 in
def C2_mux: ALU32_rr<(outs IntRegs:$Rd),
                     (ins PredRegs:$Pu, IntRegs:$Rs, IntRegs:$Rt),
      "$Rd = mux($Pu, $Rs, $Rt)", [], "", ALU32_3op_tc_1_SLOT0123>, ImmRegRel {
  bits<5> Rd;
  bits<2> Pu;
  bits<5> Rs;
  bits<5> Rt;

  let CextOpcode = "mux";
  let InputType = "reg";
  let hasSideEffects = 0;
  let IClass = 0b1111;

  let Inst{27-24} = 0b0100;
  let Inst{20-16} = Rs;
  let Inst{12-8} = Rt;
  let Inst{6-5} = Pu;
  let Inst{4-0} = Rd;
}

def: Pat<(i32 (select (i1 PredRegs:$Pu), (i32 IntRegs:$Rs), (i32 IntRegs:$Rt))),
         (C2_mux PredRegs:$Pu, IntRegs:$Rs, IntRegs:$Rt)>;

// Combines the two immediates into a double register.
// Increase complexity to make it greater than any complexity of a combine
// that involves a register.

let isReMaterializable = 1, isMoveImm = 1, isAsCheapAsAMove = 1,
    isExtentSigned = 1, isExtendable = 1, opExtentBits = 8, opExtendable = 1,
    AddedComplexity = 75, isCodeGenOnly = 0 in
def A2_combineii: ALU32Inst <(outs DoubleRegs:$Rdd), (ins s8Ext:$s8, s8Imm:$S8),
  "$Rdd = combine(#$s8, #$S8)",
  [(set (i64 DoubleRegs:$Rdd),
        (i64 (HexagonCOMBINE(i32 s8ExtPred:$s8), (i32 s8ImmPred:$S8))))]> {
    bits<5> Rdd;
    bits<8> s8;
    bits<8> S8;

    let IClass = 0b0111;
    let Inst{27-23} = 0b11000;
    let Inst{22-16} = S8{7-1};
    let Inst{13}    = S8{0};
    let Inst{12-5}  = s8;
    let Inst{4-0}   = Rdd;
  }

//===----------------------------------------------------------------------===//
// Template class for predicated ADD of a reg and an Immediate value.
//===----------------------------------------------------------------------===//
let hasNewValue = 1 in
class T_Addri_Pred <bit PredNot, bit PredNew>
  : ALU32_ri <(outs IntRegs:$Rd),
              (ins PredRegs:$Pu, IntRegs:$Rs, s8Ext:$s8),
  !if(PredNot, "if (!$Pu", "if ($Pu")#!if(PredNew,".new) $Rd = ",
  ") $Rd = ")#"add($Rs, #$s8)"> {
    bits<5> Rd;
    bits<2> Pu;
    bits<5> Rs;
    bits<8> s8;

    let isPredicatedNew = PredNew;
    let IClass = 0b0111;

    let Inst{27-24} = 0b0100;
    let Inst{23}    = PredNot;
    let Inst{22-21} = Pu;
    let Inst{20-16} = Rs;
    let Inst{13}    = PredNew;
    let Inst{12-5}  = s8;
    let Inst{4-0}   = Rd;
  }

//===----------------------------------------------------------------------===//
// A2_addi: Add a signed immediate to a register.
//===----------------------------------------------------------------------===//
let hasNewValue = 1 in
class T_Addri <Operand immOp, list<dag> pattern = [] >
  : ALU32_ri <(outs IntRegs:$Rd),
              (ins IntRegs:$Rs, immOp:$s16),
  "$Rd = add($Rs, #$s16)", pattern,
  //[(set (i32 IntRegs:$Rd), (add (i32 IntRegs:$Rs), (s16ExtPred:$s16)))],
  "", ALU32_ADDI_tc_1_SLOT0123> {
    bits<5> Rd;
    bits<5> Rs;
    bits<16> s16;

    let IClass = 0b1011;

    let Inst{27-21} = s16{15-9};
    let Inst{20-16} = Rs;
    let Inst{13-5}  = s16{8-0};
    let Inst{4-0}   = Rd;
  }

//===----------------------------------------------------------------------===//
// Multiclass for ADD of a register and an immediate value.
//===----------------------------------------------------------------------===//
multiclass Addri_Pred<string mnemonic, bit PredNot> {
  let isPredicatedFalse = PredNot in {
    def _c#NAME : T_Addri_Pred<PredNot, 0>;
    // Predicate new
    def _cdn#NAME : T_Addri_Pred<PredNot, 1>;
  }
}

let isExtendable = 1, InputType = "imm" in
multiclass Addri_base<string mnemonic, SDNode OpNode> {
  let CextOpcode = mnemonic, BaseOpcode = mnemonic#_ri in {
    let opExtendable = 2, isExtentSigned = 1, opExtentBits = 16,
    isPredicable = 1 in
    def NAME : T_Addri< s16Ext, // Rd=add(Rs,#s16)
                        [(set (i32 IntRegs:$Rd),
                              (add IntRegs:$Rs, s16ExtPred:$s16))]>;

    let opExtendable = 3, isExtentSigned = 1, opExtentBits = 8,
    hasSideEffects = 0, isPredicated = 1 in {
      defm Pt : Addri_Pred<mnemonic, 0>;
      defm NotPt : Addri_Pred<mnemonic, 1>;
    }
  }
}

let isCodeGenOnly = 0 in
defm ADD_ri : Addri_base<"add", add>, ImmRegRel, PredNewRel;

//===----------------------------------------------------------------------===//
// Template class used for the following ALU32 instructions.
// Rd=and(Rs,#s10)
// Rd=or(Rs,#s10)
//===----------------------------------------------------------------------===//
let isExtendable = 1, opExtendable = 2, isExtentSigned = 1, opExtentBits = 10,
InputType = "imm", hasNewValue = 1 in
class T_ALU32ri_logical <string mnemonic, SDNode OpNode, bits<2> MinOp>
  : ALU32_ri <(outs IntRegs:$Rd),
              (ins IntRegs:$Rs, s10Ext:$s10),
  "$Rd = "#mnemonic#"($Rs, #$s10)" ,
  [(set (i32 IntRegs:$Rd), (OpNode (i32 IntRegs:$Rs), s10ExtPred:$s10))]> {
    bits<5> Rd;
    bits<5> Rs;
    bits<10> s10;
    let CextOpcode = mnemonic;

    let IClass = 0b0111;

    let Inst{27-24} = 0b0110;
    let Inst{23-22} = MinOp;
    let Inst{21}    = s10{9};
    let Inst{20-16} = Rs;
    let Inst{13-5}  = s10{8-0};
    let Inst{4-0}   = Rd;
  }

let isCodeGenOnly = 0 in {
def OR_ri  : T_ALU32ri_logical<"or", or, 0b10>, ImmRegRel;
def AND_ri : T_ALU32ri_logical<"and", and, 0b00>, ImmRegRel;
}

// Subtract register from immediate
// Rd32=sub(#s10,Rs32)
let isExtendable = 1, opExtendable = 1, isExtentSigned = 1, opExtentBits = 10,
CextOpcode = "sub", InputType = "imm", hasNewValue = 1, isCodeGenOnly = 0 in
def SUB_ri: ALU32_ri <(outs IntRegs:$Rd), (ins s10Ext:$s10, IntRegs:$Rs),
  "$Rd = sub(#$s10, $Rs)" ,
  [(set IntRegs:$Rd, (sub s10ExtPred:$s10, IntRegs:$Rs))] > ,
  ImmRegRel {
    bits<5> Rd;
    bits<10> s10;
    bits<5> Rs;

    let IClass = 0b0111;

    let Inst{27-22} = 0b011001;
    let Inst{21}    = s10{9};
    let Inst{20-16} = Rs;
    let Inst{13-5}  = s10{8-0};
    let Inst{4-0}   = Rd;
  }

// Nop.
let hasSideEffects = 0, isCodeGenOnly = 0 in
def A2_nop: ALU32Inst <(outs), (ins), "nop" > {
  let IClass = 0b0111;
  let Inst{27-24} = 0b1111;
}
// Rd = not(Rs) gets mapped to Rd=sub(#-1, Rs).
def : Pat<(not (i32 IntRegs:$src1)),
          (SUB_ri -1, (i32 IntRegs:$src1))>;

let hasSideEffects = 0, hasNewValue = 1 in
class T_tfr16<bit isHi>
  : ALU32Inst <(outs IntRegs:$Rx), (ins IntRegs:$src1, u16Imm:$u16),
  "$Rx"#!if(isHi, ".h", ".l")#" = #$u16",
  [], "$src1 = $Rx" > {
    bits<5> Rx;
    bits<16> u16;

    let IClass = 0b0111;
    let Inst{27-26} = 0b00;
    let Inst{25-24} = !if(isHi, 0b10, 0b01);
    let Inst{23-22} = u16{15-14};
    let Inst{21}    = 0b1;
    let Inst{20-16} = Rx;
    let Inst{13-0}  = u16{13-0};
  }

let isCodeGenOnly = 0 in {
def A2_tfril: T_tfr16<0>;
def A2_tfrih: T_tfr16<1>;
}

// Conditional transfer is an alias to conditional "Rd = add(Rs, #0)".
let isPredicated = 1, hasNewValue = 1, opNewValue = 0 in
class T_tfr_pred<bit isPredNot, bit isPredNew>
  : ALU32Inst<(outs IntRegs:$dst),
              (ins PredRegs:$src1, IntRegs:$src2),
              "if ("#!if(isPredNot, "!", "")#
              "$src1"#!if(isPredNew, ".new", "")#
              ") $dst = $src2"> {
    bits<5> dst;
    bits<2> src1;
    bits<5> src2;

    let isPredicatedFalse = isPredNot;
    let isPredicatedNew = isPredNew;
    let IClass = 0b0111;

    let Inst{27-24} = 0b0100;
    let Inst{23} = isPredNot;
    let Inst{13} = isPredNew;
    let Inst{12-5} = 0;
    let Inst{4-0} = dst;
    let Inst{22-21} = src1;
    let Inst{20-16} = src2;
  }

let isPredicable = 1 in
class T_tfr : ALU32Inst<(outs IntRegs:$dst), (ins IntRegs:$src),
              "$dst = $src"> {
    bits<5> dst;
    bits<5> src;

    let IClass = 0b0111;

    let Inst{27-21} = 0b0000011;
    let Inst{20-16} = src;
    let Inst{13}    = 0b0;
    let Inst{4-0}   = dst;
  }

let InputType = "reg", hasNewValue = 1, hasSideEffects = 0 in
multiclass tfr_base<string CextOp> {
  let CextOpcode = CextOp, BaseOpcode = CextOp in {
    def NAME : T_tfr;

    // Predicate
    def t : T_tfr_pred<0, 0>;
    def f : T_tfr_pred<1, 0>;
    // Predicate new
    def tnew : T_tfr_pred<0, 1>;
    def fnew : T_tfr_pred<1, 1>;
  }
}

// Assembler mapped to C2_ccombinew[t|f|newt|newf].
// Please don't add bits to this instruction as it'll be converted into
// 'combine' before object code emission.
let isPredicated = 1 in
class T_tfrp_pred<bit PredNot, bit PredNew>
  : ALU32_rr <(outs DoubleRegs:$dst),
              (ins PredRegs:$src1, DoubleRegs:$src2),
  "if ("#!if(PredNot, "!", "")#"$src1"
        #!if(PredNew, ".new", "")#") $dst = $src2" > {
    let isPredicatedFalse = PredNot;
    let isPredicatedNew = PredNew;
  }

// Assembler mapped to A2_combinew.
// Please don't add bits to this instruction as it'll be converted into
// 'combine' before object code emission.
class T_tfrp : ALU32Inst <(outs DoubleRegs:$dst),
               (ins DoubleRegs:$src),
    "$dst = $src">;

let hasSideEffects = 0 in
multiclass TFR64_base<string BaseName> {
  let BaseOpcode = BaseName in {
    let isPredicable = 1 in
    def NAME : T_tfrp;
    // Predicate
    def t : T_tfrp_pred <0, 0>;
    def f : T_tfrp_pred <1, 0>;
    // Predicate new
    def tnew : T_tfrp_pred <0, 1>;
    def fnew : T_tfrp_pred <1, 1>;
  }
}

let InputType = "imm", isExtendable = 1, isExtentSigned = 1, opExtentBits = 12,
    isMoveImm = 1, opExtendable = 2, BaseOpcode = "TFRI", CextOpcode = "TFR",
    hasSideEffects = 0, isPredicated = 1, hasNewValue = 1 in
class T_TFRI_Pred<bit PredNot, bit PredNew>
  : ALU32_ri<(outs IntRegs:$Rd), (ins PredRegs:$Pu, s12Ext:$s12),
    "if ("#!if(PredNot,"!","")#"$Pu"#!if(PredNew,".new","")#") $Rd = #$s12",
    [], "", ALU32_2op_tc_1_SLOT0123>, ImmRegRel, PredNewRel {
  let isPredicatedFalse = PredNot;
  let isPredicatedNew = PredNew;

  bits<5> Rd;
  bits<2> Pu;
  bits<12> s12;

  let IClass = 0b0111;
  let Inst{27-24} = 0b1110;
  let Inst{23} = PredNot;
  let Inst{22-21} = Pu;
  let Inst{20} = 0b0;
  let Inst{19-16,12-5} = s12;
  let Inst{13} = PredNew;
  let Inst{4-0} = Rd;
}

let isCodeGenOnly = 0 in {
def C2_cmoveit    : T_TFRI_Pred<0, 0>;
def C2_cmoveif    : T_TFRI_Pred<1, 0>;
def C2_cmovenewit : T_TFRI_Pred<0, 1>;
def C2_cmovenewif : T_TFRI_Pred<1, 1>;
}

let InputType = "imm", isExtendable = 1, isExtentSigned = 1,
    CextOpcode = "TFR", BaseOpcode = "TFRI", hasNewValue = 1, opNewValue = 0,
    isAsCheapAsAMove = 1 , opExtendable = 1, opExtentBits = 16, isMoveImm = 1,
    isPredicated = 0, isPredicable = 1, isReMaterializable = 1,
    isCodeGenOnly = 0 in
def A2_tfrsi : ALU32Inst<(outs IntRegs:$Rd), (ins s16Ext:$s16), "$Rd = #$s16",
    [(set (i32 IntRegs:$Rd), s16ExtPred:$s16)], "", ALU32_2op_tc_1_SLOT0123>,
    ImmRegRel, PredRel {
  bits<5> Rd;
  bits<16> s16;

  let IClass = 0b0111;
  let Inst{27-24} = 0b1000;
  let Inst{23-22,20-16,13-5} = s16;
  let Inst{4-0} = Rd;
}

let isCodeGenOnly = 0 in
defm A2_tfr  : tfr_base<"TFR">, ImmRegRel, PredNewRel;
defm A2_tfrp : TFR64_base<"TFR64">, PredNewRel;

// Assembler mapped
let isReMaterializable = 1, isMoveImm = 1, isAsCheapAsAMove = 1 in
def A2_tfrpi : ALU64_rr<(outs DoubleRegs:$dst), (ins s8Imm64:$src1),
                      "$dst = #$src1",
                      [(set (i64 DoubleRegs:$dst), s8Imm64Pred:$src1)]>;

// TODO: see if this instruction can be deleted..
let isExtendable = 1, opExtendable = 1, opExtentBits = 6 in
def TFRI64_V4 : ALU64_rr<(outs DoubleRegs:$dst), (ins u6Ext:$src1),
                         "$dst = #$src1">;

// Transfer control register.
let hasSideEffects = 0 in
def TFCR : CRInst<(outs CRRegs:$dst), (ins IntRegs:$src1),
           "$dst = $src1",
           []>;
//===----------------------------------------------------------------------===//
// ALU32/ALU -
//===----------------------------------------------------------------------===//


//===----------------------------------------------------------------------===//
// ALU32/PERM +
//===----------------------------------------------------------------------===//
// Scalar mux register immediate.
let hasSideEffects = 0, isExtentSigned = 1, CextOpcode = "MUX",
    InputType = "imm", hasNewValue = 1, isExtendable = 1, opExtentBits = 8 in
class T_MUX1 <bit MajOp, dag ins, string AsmStr>
      : ALU32Inst <(outs IntRegs:$Rd), ins, AsmStr>, ImmRegRel {
  bits<5> Rd;
  bits<2> Pu;
  bits<8> s8;
  bits<5> Rs;

  let IClass = 0b0111;
  let Inst{27-24} = 0b0011;
  let Inst{23} = MajOp;
  let Inst{22-21} = Pu;
  let Inst{20-16} = Rs;
  let Inst{13}    = 0b0;
  let Inst{12-5}  = s8;
  let Inst{4-0}   = Rd;
}

let opExtendable = 2, isCodeGenOnly = 0 in
def C2_muxri : T_MUX1<0b1, (ins PredRegs:$Pu, s8Ext:$s8, IntRegs:$Rs),
                           "$Rd = mux($Pu, #$s8, $Rs)">;

let opExtendable = 3, isCodeGenOnly = 0 in
def C2_muxir : T_MUX1<0b0, (ins PredRegs:$Pu, IntRegs:$Rs, s8Ext:$s8),
                           "$Rd = mux($Pu, $Rs, #$s8)">;

def : Pat<(i32 (select I1:$Pu, s8ExtPred:$s8, I32:$Rs)),
          (C2_muxri I1:$Pu, s8ExtPred:$s8, I32:$Rs)>;

def : Pat<(i32 (select I1:$Pu, I32:$Rs, s8ExtPred:$s8)),
          (C2_muxir I1:$Pu, I32:$Rs, s8ExtPred:$s8)>;

// C2_muxii: Scalar mux immediates.
let isExtentSigned = 1, hasNewValue = 1, isExtendable = 1,
    opExtentBits = 8, opExtendable = 2, isCodeGenOnly = 0 in
def C2_muxii: ALU32Inst <(outs IntRegs:$Rd),
                         (ins PredRegs:$Pu, s8Ext:$s8, s8Imm:$S8),
  "$Rd = mux($Pu, #$s8, #$S8)" ,
  [(set (i32 IntRegs:$Rd),
        (i32 (select I1:$Pu, s8ExtPred:$s8, s8ImmPred:$S8)))] > {
    bits<5> Rd;
    bits<2> Pu;
    bits<8> s8;
    bits<8> S8;

    let IClass = 0b0111;

    let Inst{27-25} = 0b101;
    let Inst{24-23} = Pu;
    let Inst{22-16} = S8{7-1};
    let Inst{13}    = S8{0};
    let Inst{12-5}  = s8;
    let Inst{4-0}   = Rd;
  }

//===----------------------------------------------------------------------===//
// template class for non-predicated alu32_2op instructions
// - aslh, asrh, sxtb, sxth, zxth
//===----------------------------------------------------------------------===//
let hasNewValue = 1, opNewValue = 0 in
class T_ALU32_2op <string mnemonic, bits<3> minOp> :
    ALU32Inst < (outs IntRegs:$Rd), (ins IntRegs:$Rs),
    "$Rd = "#mnemonic#"($Rs)", [] > {
  bits<5> Rd;
  bits<5> Rs;

  let IClass = 0b0111;

  let Inst{27-24} = 0b0000;
  let Inst{23-21} = minOp;
  let Inst{13} = 0b0;
  let Inst{4-0} = Rd;
  let Inst{20-16} = Rs;
}

//===----------------------------------------------------------------------===//
// template class for predicated alu32_2op instructions
// - aslh, asrh, sxtb, sxth, zxtb, zxth
//===----------------------------------------------------------------------===//
let hasSideEffects = 0, validSubTargets = HasV4SubT,
    hasNewValue = 1, opNewValue = 0 in
class T_ALU32_2op_Pred <string mnemonic, bits<3> minOp, bit isPredNot, 
    bit isPredNew > :
    ALU32Inst <(outs IntRegs:$Rd), (ins PredRegs:$Pu, IntRegs:$Rs),
    !if(isPredNot, "if (!$Pu", "if ($Pu")
    #!if(isPredNew, ".new) ",") ")#"$Rd = "#mnemonic#"($Rs)"> {
  bits<5> Rd;
  bits<2> Pu;
  bits<5> Rs;

  let IClass = 0b0111;

  let Inst{27-24} = 0b0000;
  let Inst{23-21} = minOp;
  let Inst{13} = 0b1;
  let Inst{11} = isPredNot;
  let Inst{10} = isPredNew;
  let Inst{4-0} = Rd;
  let Inst{9-8} = Pu;
  let Inst{20-16} = Rs;
}

multiclass ALU32_2op_Pred<string mnemonic, bits<3> minOp, bit PredNot> {
  let isPredicatedFalse = PredNot in {
    def NAME : T_ALU32_2op_Pred<mnemonic, minOp, PredNot, 0>;

    // Predicate new
    let isPredicatedNew = 1 in
    def NAME#new : T_ALU32_2op_Pred<mnemonic, minOp, PredNot, 1>;
  }
}

multiclass ALU32_2op_base<string mnemonic, bits<3> minOp> {
  let BaseOpcode = mnemonic in {
    let isPredicable = 1, hasSideEffects = 0 in
    def A2_#NAME : T_ALU32_2op<mnemonic, minOp>;

    let validSubTargets = HasV4SubT, isPredicated = 1, hasSideEffects = 0 in {
      defm A4_p#NAME#t : ALU32_2op_Pred<mnemonic, minOp, 0>;
      defm A4_p#NAME#f : ALU32_2op_Pred<mnemonic, minOp, 1>;
    }
  }
}

let isCodeGenOnly = 0 in {
defm aslh : ALU32_2op_base<"aslh", 0b000>, PredNewRel;
defm asrh : ALU32_2op_base<"asrh", 0b001>, PredNewRel;
defm sxtb : ALU32_2op_base<"sxtb", 0b101>, PredNewRel;
defm sxth : ALU32_2op_base<"sxth", 0b111>, PredNewRel;
defm zxth : ALU32_2op_base<"zxth", 0b110>, PredNewRel;
}

// Rd=zxtb(Rs): assembler mapped to Rd=and(Rs,#255).
// Compiler would want to generate 'zxtb' instead of 'and' becuase 'zxtb' has
// predicated forms while 'and' doesn't. Since integrated assembler can't
// handle 'mapped' instructions, we need to encode 'zxtb' same as 'and' where
// immediate operand is set to '255'.

let hasNewValue = 1, opNewValue = 0 in
class T_ZXTB: ALU32Inst < (outs IntRegs:$Rd), (ins IntRegs:$Rs),
  "$Rd = zxtb($Rs)", [] > { // Rd = and(Rs,255)
    bits<5> Rd;
    bits<5> Rs;
    bits<10> s10 = 255;

    let IClass = 0b0111;

    let Inst{27-22} = 0b011000;
    let Inst{4-0} = Rd;
    let Inst{20-16} = Rs;
    let Inst{21} = s10{9};
    let Inst{13-5} = s10{8-0};
}

//Rd=zxtb(Rs): assembler mapped to "Rd=and(Rs,#255)
multiclass ZXTB_base <string mnemonic, bits<3> minOp> {
  let BaseOpcode = mnemonic in {
    let isPredicable = 1, hasSideEffects = 0 in
    def A2_#NAME : T_ZXTB;

    let validSubTargets = HasV4SubT, isPredicated = 1, hasSideEffects = 0 in {
      defm A4_p#NAME#t : ALU32_2op_Pred<mnemonic, minOp, 0>;
      defm A4_p#NAME#f : ALU32_2op_Pred<mnemonic, minOp, 1>;
    }
  }
}

let isCodeGenOnly=0 in
defm zxtb : ZXTB_base<"zxtb",0b100>, PredNewRel;

def: Pat<(shl I32:$src1, (i32 16)),   (A2_aslh I32:$src1)>;
def: Pat<(sra I32:$src1, (i32 16)),   (A2_asrh I32:$src1)>;
def: Pat<(sext_inreg I32:$src1, i8),  (A2_sxtb I32:$src1)>;
def: Pat<(sext_inreg I32:$src1, i16), (A2_sxth I32:$src1)>;

// Mux.
def VMUX_prr64 : ALU64_rr<(outs DoubleRegs:$dst), (ins PredRegs:$src1,
                                                   DoubleRegs:$src2,
                                                   DoubleRegs:$src3),
            "$dst = vmux($src1, $src2, $src3)",
            []>;


//===----------------------------------------------------------------------===//
// ALU32/PERM -
//===----------------------------------------------------------------------===//


//===----------------------------------------------------------------------===//
// ALU32/PRED +
//===----------------------------------------------------------------------===//

// SDNode for converting immediate C to C-1.
def DEC_CONST_SIGNED : SDNodeXForm<imm, [{
   // Return the byte immediate const-1 as an SDNode.
   int32_t imm = N->getSExtValue();
   return XformSToSM1Imm(imm);
}]>;

// SDNode for converting immediate C to C-1.
def DEC_CONST_UNSIGNED : SDNodeXForm<imm, [{
   // Return the byte immediate const-1 as an SDNode.
   uint32_t imm = N->getZExtValue();
   return XformUToUM1Imm(imm);
}]>;

def CTLZ_rr : SInst<(outs IntRegs:$dst), (ins IntRegs:$src1),
    "$dst = cl0($src1)",
    [(set (i32 IntRegs:$dst), (ctlz (i32 IntRegs:$src1)))]>;

def CTTZ_rr : SInst<(outs IntRegs:$dst), (ins IntRegs:$src1),
    "$dst = ct0($src1)",
    [(set (i32 IntRegs:$dst), (cttz (i32 IntRegs:$src1)))]>;

def CTLZ64_rr : SInst<(outs IntRegs:$dst), (ins DoubleRegs:$src1),
    "$dst = cl0($src1)",
    [(set (i32 IntRegs:$dst), (i32 (trunc (ctlz (i64 DoubleRegs:$src1)))))]>;

def CTTZ64_rr : SInst<(outs IntRegs:$dst), (ins DoubleRegs:$src1),
    "$dst = ct0($src1)",
    [(set (i32 IntRegs:$dst), (i32 (trunc (cttz (i64 DoubleRegs:$src1)))))]>;

def TSTBIT_rr : SInst<(outs PredRegs:$dst), (ins IntRegs:$src1, IntRegs:$src2),
    "$dst = tstbit($src1, $src2)",
    [(set (i1 PredRegs:$dst),
          (setne (and (shl 1, (i32 IntRegs:$src2)), (i32 IntRegs:$src1)), 0))]>;

//===----------------------------------------------------------------------===//
// ALU32/PRED -
//===----------------------------------------------------------------------===//


//===----------------------------------------------------------------------===//
// ALU64/ALU +
//===----------------------------------------------------------------------===//// Add.
//===----------------------------------------------------------------------===//
// Template Class
// Add/Subtract halfword
// Rd=add(Rt.L,Rs.[HL])[:sat]
// Rd=sub(Rt.L,Rs.[HL])[:sat]
// Rd=add(Rt.[LH],Rs.[HL])[:sat][:<16]
// Rd=sub(Rt.[LH],Rs.[HL])[:sat][:<16]
//===----------------------------------------------------------------------===//

let  hasNewValue = 1, opNewValue = 0 in
class T_XTYPE_ADD_SUB <bits<2> LHbits, bit isSat, bit hasShift, bit isSub>
  : ALU64Inst <(outs IntRegs:$Rd), (ins IntRegs:$Rt, IntRegs:$Rs),
  "$Rd = "#!if(isSub,"sub","add")#"($Rt."
          #!if(hasShift, !if(LHbits{1},"h","l"),"l") #", $Rs."
          #!if(hasShift, !if(LHbits{0},"h)","l)"), !if(LHbits{1},"h)","l)"))
          #!if(isSat,":sat","")
          #!if(hasShift,":<<16",""), [], "", ALU64_tc_1_SLOT23> {
    bits<5> Rd;
    bits<5> Rt;
    bits<5> Rs;
    let IClass = 0b1101;

    let Inst{27-23} = 0b01010;
    let Inst{22} = hasShift;
    let Inst{21} = isSub;
    let Inst{7} = isSat;
    let Inst{6-5} = LHbits;
    let Inst{4-0} = Rd;
    let Inst{12-8} = Rt;
    let Inst{20-16} = Rs;
  }

//Rd=sub(Rt.L,Rs.[LH])
let isCodeGenOnly = 0 in {
def A2_subh_l16_ll : T_XTYPE_ADD_SUB <0b00, 0, 0, 1>;
def A2_subh_l16_hl : T_XTYPE_ADD_SUB <0b10, 0, 0, 1>;
}

let isCodeGenOnly = 0 in {
//Rd=add(Rt.L,Rs.[LH])
def A2_addh_l16_ll : T_XTYPE_ADD_SUB <0b00, 0, 0, 0>;
def A2_addh_l16_hl : T_XTYPE_ADD_SUB <0b10, 0, 0, 0>;
}

let Itinerary = ALU64_tc_2_SLOT23, Defs = [USR_OVF], isCodeGenOnly = 0 in {
  //Rd=sub(Rt.L,Rs.[LH]):sat
  def A2_subh_l16_sat_ll : T_XTYPE_ADD_SUB <0b00, 1, 0, 1>;
  def A2_subh_l16_sat_hl : T_XTYPE_ADD_SUB <0b10, 1, 0, 1>;

  //Rd=add(Rt.L,Rs.[LH]):sat
  def A2_addh_l16_sat_ll : T_XTYPE_ADD_SUB <0b00, 1, 0, 0>;
  def A2_addh_l16_sat_hl : T_XTYPE_ADD_SUB <0b10, 1, 0, 0>;
}

//Rd=sub(Rt.[LH],Rs.[LH]):<<16
let isCodeGenOnly = 0 in {
def A2_subh_h16_ll : T_XTYPE_ADD_SUB <0b00, 0, 1, 1>;
def A2_subh_h16_lh : T_XTYPE_ADD_SUB <0b01, 0, 1, 1>;
def A2_subh_h16_hl : T_XTYPE_ADD_SUB <0b10, 0, 1, 1>;
def A2_subh_h16_hh : T_XTYPE_ADD_SUB <0b11, 0, 1, 1>;
}

//Rd=add(Rt.[LH],Rs.[LH]):<<16
let isCodeGenOnly = 0 in {
def A2_addh_h16_ll : T_XTYPE_ADD_SUB <0b00, 0, 1, 0>;
def A2_addh_h16_lh : T_XTYPE_ADD_SUB <0b01, 0, 1, 0>;
def A2_addh_h16_hl : T_XTYPE_ADD_SUB <0b10, 0, 1, 0>;
def A2_addh_h16_hh : T_XTYPE_ADD_SUB <0b11, 0, 1, 0>;
}

let Itinerary = ALU64_tc_2_SLOT23, Defs = [USR_OVF], isCodeGenOnly = 0 in {
  //Rd=sub(Rt.[LH],Rs.[LH]):sat:<<16
  def A2_subh_h16_sat_ll : T_XTYPE_ADD_SUB <0b00, 1, 1, 1>;
  def A2_subh_h16_sat_lh : T_XTYPE_ADD_SUB <0b01, 1, 1, 1>;
  def A2_subh_h16_sat_hl : T_XTYPE_ADD_SUB <0b10, 1, 1, 1>;
  def A2_subh_h16_sat_hh : T_XTYPE_ADD_SUB <0b11, 1, 1, 1>;

  //Rd=add(Rt.[LH],Rs.[LH]):sat:<<16
  def A2_addh_h16_sat_ll : T_XTYPE_ADD_SUB <0b00, 1, 1, 0>;
  def A2_addh_h16_sat_lh : T_XTYPE_ADD_SUB <0b01, 1, 1, 0>;
  def A2_addh_h16_sat_hl : T_XTYPE_ADD_SUB <0b10, 1, 1, 0>;
  def A2_addh_h16_sat_hh : T_XTYPE_ADD_SUB <0b11, 1, 1, 0>;
}

// Add halfword.
def: Pat<(sext_inreg (add I32:$src1, I32:$src2), i16),
         (A2_addh_l16_ll I32:$src1, I32:$src2)>;

def: Pat<(sra (add (shl I32:$src1, (i32 16)), I32:$src2), (i32 16)),
         (A2_addh_l16_hl I32:$src1, I32:$src2)>;

def: Pat<(shl (add I32:$src1, I32:$src2), (i32 16)),
         (A2_addh_h16_ll I32:$src1, I32:$src2)>;

// Subtract halfword.
def: Pat<(sext_inreg (sub I32:$src1, I32:$src2), i16),
         (A2_subh_l16_ll I32:$src1, I32:$src2)>;

def: Pat<(shl (sub I32:$src1, I32:$src2), (i32 16)),
         (A2_subh_h16_ll I32:$src1, I32:$src2)>;

let hasSideEffects = 0, hasNewValue = 1, isCodeGenOnly = 0 in
def S2_parityp: ALU64Inst<(outs IntRegs:$Rd),
      (ins DoubleRegs:$Rs, DoubleRegs:$Rt),
      "$Rd = parity($Rs, $Rt)", [], "", ALU64_tc_2_SLOT23> {
  bits<5> Rd;
  bits<5> Rs;
  bits<5> Rt;

  let IClass = 0b1101;
  let Inst{27-24} = 0b0000;
  let Inst{20-16} = Rs;
  let Inst{12-8} = Rt;
  let Inst{4-0} = Rd;
}

let hasNewValue = 1, opNewValue = 0, hasSideEffects = 0 in
class T_XTYPE_MIN_MAX < bit isMax, bit isUnsigned >
  : ALU64Inst < (outs IntRegs:$Rd), (ins IntRegs:$Rt, IntRegs:$Rs),
  "$Rd = "#!if(isMax,"max","min")#!if(isUnsigned,"u","")
          #"($Rt, $Rs)", [], "", ALU64_tc_2_SLOT23> {
    bits<5> Rd;
    bits<5> Rt;
    bits<5> Rs;

    let IClass = 0b1101;

    let Inst{27-23} = 0b01011;
    let Inst{22-21} = !if(isMax, 0b10, 0b01);
    let Inst{7} = isUnsigned;
    let Inst{4-0} = Rd;
    let Inst{12-8} = !if(isMax, Rs, Rt);
    let Inst{20-16} = !if(isMax, Rt, Rs);
  }

let isCodeGenOnly = 0 in {
def A2_min  : T_XTYPE_MIN_MAX < 0, 0 >;
def A2_minu : T_XTYPE_MIN_MAX < 0, 1 >;
def A2_max  : T_XTYPE_MIN_MAX < 1, 0 >;
def A2_maxu : T_XTYPE_MIN_MAX < 1, 1 >;
}

// Here, depending on  the operand being selected, we'll either generate a
// min or max instruction.
// Ex:
// (a>b)?a:b --> max(a,b) => Here check performed is '>' and the value selected
// is the larger of two. So, the corresponding HexagonInst is passed in 'Inst'.
// (a>b)?b:a --> min(a,b) => Here check performed is '>' but the smaller value
// is selected and the corresponding HexagonInst is passed in 'SwapInst'.

multiclass T_MinMax_pats <PatFrag Op, RegisterClass RC, ValueType VT,
                          InstHexagon Inst, InstHexagon SwapInst> {
  def: Pat<(select (i1 (Op (VT RC:$src1), (VT RC:$src2))),
                   (VT RC:$src1), (VT RC:$src2)),
           (Inst RC:$src1, RC:$src2)>;
  def: Pat<(select (i1 (Op (VT RC:$src1), (VT RC:$src2))),
                   (VT RC:$src2), (VT RC:$src1)),
           (SwapInst RC:$src1, RC:$src2)>;
}


multiclass MinMax_pats <PatFrag Op, InstHexagon Inst, InstHexagon SwapInst> {
  defm: T_MinMax_pats<Op, IntRegs, i32, Inst, SwapInst>;

  def: Pat<(sext_inreg (i32 (select (i1 (Op (i32 PositiveHalfWord:$src1),
                                            (i32 PositiveHalfWord:$src2))),
                                    (i32 PositiveHalfWord:$src1),
                                    (i32 PositiveHalfWord:$src2))), i16),
           (Inst IntRegs:$src1, IntRegs:$src2)>;

  def: Pat<(sext_inreg (i32 (select (i1 (Op (i32 PositiveHalfWord:$src1),
                                            (i32 PositiveHalfWord:$src2))),
                                    (i32 PositiveHalfWord:$src2),
                                    (i32 PositiveHalfWord:$src1))), i16),
           (SwapInst IntRegs:$src1, IntRegs:$src2)>;
}

let AddedComplexity = 200 in {
  defm: MinMax_pats<setge,  A2_max,  A2_min>;
  defm: MinMax_pats<setgt,  A2_max,  A2_min>;
  defm: MinMax_pats<setle,  A2_min,  A2_max>;
  defm: MinMax_pats<setlt,  A2_min,  A2_max>;
  defm: MinMax_pats<setuge, A2_maxu, A2_minu>;
  defm: MinMax_pats<setugt, A2_maxu, A2_minu>;
  defm: MinMax_pats<setule, A2_minu, A2_maxu>;
  defm: MinMax_pats<setult, A2_minu, A2_maxu>;
}

class T_cmp64_rr<string mnemonic, bits<3> MinOp, bit IsComm>
  : ALU64_rr<(outs PredRegs:$Pd), (ins DoubleRegs:$Rs, DoubleRegs:$Rt),
             "$Pd = "#mnemonic#"($Rs, $Rt)", [], "", ALU64_tc_2early_SLOT23> {
  let isCompare = 1;
  let isCommutable = IsComm;
  let hasSideEffects = 0;

  bits<2> Pd;
  bits<5> Rs;
  bits<5> Rt;

  let IClass = 0b1101;
  let Inst{27-21} = 0b0010100;
  let Inst{20-16} = Rs;
  let Inst{12-8} = Rt;
  let Inst{7-5} = MinOp;
  let Inst{1-0} = Pd;
}

let isCodeGenOnly = 0 in {
def C2_cmpeqp  : T_cmp64_rr<"cmp.eq",  0b000, 1>;
def C2_cmpgtp  : T_cmp64_rr<"cmp.gt",  0b010, 0>;
def C2_cmpgtup : T_cmp64_rr<"cmp.gtu", 0b100, 0>;
}

class T_cmp64_rr_pat<InstHexagon MI, PatFrag CmpOp>
  : Pat<(i1 (CmpOp (i64 DoubleRegs:$Rs), (i64 DoubleRegs:$Rt))),
        (i1 (MI DoubleRegs:$Rs, DoubleRegs:$Rt))>;

def: T_cmp64_rr_pat<C2_cmpeqp,  seteq>;
def: T_cmp64_rr_pat<C2_cmpgtp,  setgt>;
def: T_cmp64_rr_pat<C2_cmpgtup, setugt>;
def: T_cmp64_rr_pat<C2_cmpgtp,  RevCmp<setlt>>;
def: T_cmp64_rr_pat<C2_cmpgtup, RevCmp<setult>>;

class T_ALU64_rr<string mnemonic, string suffix, bits<4> RegType,
                 bits<3> MajOp, bits<3> MinOp, bit OpsRev, bit IsComm,
                 string Op2Pfx>
  : ALU64_rr<(outs DoubleRegs:$Rd), (ins DoubleRegs:$Rs, DoubleRegs:$Rt),
             "$Rd = " #mnemonic# "($Rs, " #Op2Pfx# "$Rt)" #suffix, [],
             "", ALU64_tc_1_SLOT23> {
  let hasSideEffects = 0;
  let isCommutable = IsComm;

  bits<5> Rs;
  bits<5> Rt;
  bits<5> Rd;

  let IClass = 0b1101;
  let Inst{27-24} = RegType;
  let Inst{23-21} = MajOp;
  let Inst{20-16} = !if (OpsRev,Rt,Rs);
  let Inst{12-8} = !if (OpsRev,Rs,Rt);
  let Inst{7-5} = MinOp;
  let Inst{4-0} = Rd;
}

class T_ALU64_arith<string mnemonic, bits<3> MajOp, bits<3> MinOp, bit IsSat,
                    bit OpsRev, bit IsComm>
  : T_ALU64_rr<mnemonic, !if(IsSat,":sat",""), 0b0011, MajOp, MinOp, OpsRev,
               IsComm, "">;

let isCodeGenOnly = 0 in {
def A2_addp : T_ALU64_arith<"add", 0b000, 0b111, 0, 0, 1>;
def A2_subp : T_ALU64_arith<"sub", 0b001, 0b111, 0, 1, 0>;
}

def: Pat<(i64 (add I64:$Rs, I64:$Rt)), (A2_addp I64:$Rs, I64:$Rt)>;
def: Pat<(i64 (sub I64:$Rs, I64:$Rt)), (A2_subp I64:$Rs, I64:$Rt)>;

class T_ALU64_logical<string mnemonic, bits<3> MinOp, bit OpsRev, bit IsComm,
                      bit IsNeg>
  : T_ALU64_rr<mnemonic, "", 0b0011, 0b111, MinOp, OpsRev, IsComm,
               !if(IsNeg,"~","")>;

let isCodeGenOnly = 0 in {
def A2_andp : T_ALU64_logical<"and", 0b000, 0, 1, 0>;
def A2_orp  : T_ALU64_logical<"or",  0b010, 0, 1, 0>;
def A2_xorp : T_ALU64_logical<"xor", 0b100, 0, 1, 0>;
}

def: Pat<(i64 (and I64:$Rs, I64:$Rt)), (A2_andp I64:$Rs, I64:$Rt)>;
def: Pat<(i64 (or  I64:$Rs, I64:$Rt)), (A2_orp  I64:$Rs, I64:$Rt)>;
def: Pat<(i64 (xor I64:$Rs, I64:$Rt)), (A2_xorp I64:$Rs, I64:$Rt)>;

//===----------------------------------------------------------------------===//
// ALU64/ALU -
//===----------------------------------------------------------------------===//

//===----------------------------------------------------------------------===//
// ALU64/BIT +
//===----------------------------------------------------------------------===//
//
//===----------------------------------------------------------------------===//
// ALU64/BIT -
//===----------------------------------------------------------------------===//

//===----------------------------------------------------------------------===//
// ALU64/PERM +
//===----------------------------------------------------------------------===//
//
//===----------------------------------------------------------------------===//
// ALU64/PERM -
//===----------------------------------------------------------------------===//

//===----------------------------------------------------------------------===//
// CR +
//===----------------------------------------------------------------------===//
// Logical reductions on predicates.

// Looping instructions.

// Pipelined looping instructions.

// Logical operations on predicates.
let hasSideEffects = 0 in
class T_LOGICAL_1OP<string MnOp, bits<2> OpBits>
    : CRInst<(outs PredRegs:$Pd), (ins PredRegs:$Ps),
             "$Pd = " # MnOp # "($Ps)", [], "", CR_tc_2early_SLOT23> {
  bits<2> Pd;
  bits<2> Ps;

  let IClass = 0b0110;
  let Inst{27-23} = 0b10111;
  let Inst{22-21} = OpBits;
  let Inst{20} = 0b0;
  let Inst{17-16} = Ps;
  let Inst{13} = 0b0;
  let Inst{1-0} = Pd;
}

let isCodeGenOnly = 0 in {
def C2_any8 : T_LOGICAL_1OP<"any8", 0b00>;
def C2_all8 : T_LOGICAL_1OP<"all8", 0b01>;
def C2_not  : T_LOGICAL_1OP<"not",  0b10>;
}

def: Pat<(i1 (not (i1 PredRegs:$Ps))),
         (C2_not PredRegs:$Ps)>;

let hasSideEffects = 0 in
class T_LOGICAL_2OP<string MnOp, bits<3> OpBits, bit IsNeg, bit Rev>
    : CRInst<(outs PredRegs:$Pd), (ins PredRegs:$Ps, PredRegs:$Pt),
             "$Pd = " # MnOp # "($Ps, " # !if (IsNeg,"!","") # "$Pt)",
             [], "", CR_tc_2early_SLOT23> {
  bits<2> Pd;
  bits<2> Ps;
  bits<2> Pt;

  let IClass = 0b0110;
  let Inst{27-24} = 0b1011;
  let Inst{23-21} = OpBits;
  let Inst{20} = 0b0;
  let Inst{17-16} = !if(Rev,Pt,Ps);  // Rs and Rt are reversed for some
  let Inst{13} = 0b0;                // instructions.
  let Inst{9-8} = !if(Rev,Ps,Pt);
  let Inst{1-0} = Pd;
}

let isCodeGenOnly = 0 in {
def C2_and  : T_LOGICAL_2OP<"and", 0b000, 0, 1>;
def C2_or   : T_LOGICAL_2OP<"or",  0b001, 0, 1>;
def C2_xor  : T_LOGICAL_2OP<"xor", 0b010, 0, 0>;
def C2_andn : T_LOGICAL_2OP<"and", 0b011, 1, 1>;
def C2_orn  : T_LOGICAL_2OP<"or",  0b111, 1, 1>;
}

def: Pat<(i1 (and I1:$Ps, I1:$Pt)),       (C2_and  I1:$Ps, I1:$Pt)>;
def: Pat<(i1 (or  I1:$Ps, I1:$Pt)),       (C2_or   I1:$Ps, I1:$Pt)>;
def: Pat<(i1 (xor I1:$Ps, I1:$Pt)),       (C2_xor  I1:$Ps, I1:$Pt)>;
def: Pat<(i1 (and I1:$Ps, (not I1:$Pt))), (C2_andn I1:$Ps, I1:$Pt)>;
def: Pat<(i1 (or  I1:$Ps, (not I1:$Pt))), (C2_orn  I1:$Ps, I1:$Pt)>;

let hasSideEffects = 0, hasNewValue = 1, isCodeGenOnly = 0 in
def C2_vitpack : SInst<(outs IntRegs:$Rd), (ins PredRegs:$Ps, PredRegs:$Pt),
      "$Rd = vitpack($Ps, $Pt)", [], "", S_2op_tc_1_SLOT23> {
  bits<5> Rd;
  bits<2> Ps;
  bits<2> Pt;

  let IClass = 0b1000;
  let Inst{27-24} = 0b1001;
  let Inst{22-21} = 0b00;
  let Inst{17-16} = Ps;
  let Inst{9-8} = Pt;
  let Inst{4-0} = Rd;
}

let hasSideEffects = 0, isCodeGenOnly = 0 in
def C2_mask : SInst<(outs DoubleRegs:$Rd), (ins PredRegs:$Pt),
      "$Rd = mask($Pt)", [], "", S_2op_tc_1_SLOT23> {
  bits<5> Rd;
  bits<2> Pt;

  let IClass = 0b1000;
  let Inst{27-24} = 0b0110;
  let Inst{9-8} = Pt;
  let Inst{4-0} = Rd;
}

def VALIGN_rrp : SInst<(outs DoubleRegs:$dst), (ins DoubleRegs:$src1,
                                                    DoubleRegs:$src2,
                                                    PredRegs:$src3),
             "$dst = valignb($src1, $src2, $src3)",
             []>;

def VSPLICE_rrp : SInst<(outs DoubleRegs:$dst), (ins DoubleRegs:$src1,
                                                     DoubleRegs:$src2,
                                                     PredRegs:$src3),
             "$dst = vspliceb($src1, $src2, $src3)",
             []>;

// User control register transfer.
//===----------------------------------------------------------------------===//
// CR -
//===----------------------------------------------------------------------===//

//===----------------------------------------------------------------------===//
// JR +
//===----------------------------------------------------------------------===//

def retflag : SDNode<"HexagonISD::RET_FLAG", SDTNone,
                               [SDNPHasChain, SDNPOptInGlue, SDNPVariadic]>;
def eh_return: SDNode<"HexagonISD::EH_RETURN", SDTNone, [SDNPHasChain]>;

def SDHexagonBR_JT: SDTypeProfile<0, 1, [SDTCisVT<0, i32>]>;
def HexagonBR_JT: SDNode<"HexagonISD::BR_JT", SDHexagonBR_JT, [SDNPHasChain]>;

class CondStr<string CReg, bit True, bit New> {
  string S = "if (" # !if(True,"","!") # CReg # !if(New,".new","") # ") ";
}
class JumpOpcStr<string Mnemonic, bit New, bit Taken> {
  string S = Mnemonic # !if(New, !if(Taken,":t",":nt"), "");
}

let isBranch = 1, isBarrier = 1, Defs = [PC], hasSideEffects = 0,
    isPredicable = 1,
    isExtendable = 1, opExtendable = 0, isExtentSigned = 1,
    opExtentBits = 24, opExtentAlign = 2, InputType = "imm" in
class T_JMP<string ExtStr>
  : JInst<(outs), (ins brtarget:$dst),
      "jump " # ExtStr # "$dst",
      [], "", J_tc_2early_SLOT23> {
    bits<24> dst;
    let IClass = 0b0101;

    let Inst{27-25} = 0b100;
    let Inst{24-16} = dst{23-15};
    let Inst{13-1} = dst{14-2};
}

let isBranch = 1, Defs = [PC], hasSideEffects = 0, isPredicated = 1,
    isExtendable = 1, opExtendable = 1, isExtentSigned = 1,
    opExtentBits = 17, opExtentAlign = 2, InputType = "imm" in
class T_JMP_c<bit PredNot, bit isPredNew, bit isTak, string ExtStr>
  : JInst<(outs), (ins PredRegs:$src, brtarget:$dst),
      CondStr<"$src", !if(PredNot,0,1), isPredNew>.S #
        JumpOpcStr<"jump", isPredNew, isTak>.S # " " #
        ExtStr # "$dst",
      [], "", J_tc_2early_SLOT23>, ImmRegRel {
    let isTaken = isTak;
    let isPredicatedFalse = PredNot;
    let isPredicatedNew = isPredNew;
    bits<2> src;
    bits<17> dst;

    let IClass = 0b0101;

    let Inst{27-24} = 0b1100;
    let Inst{21} = PredNot;
    let Inst{12} = !if(isPredNew, isTak, zero);
    let Inst{11} = isPredNew;
    let Inst{9-8} = src;
    let Inst{23-22} = dst{16-15};
    let Inst{20-16} = dst{14-10};
    let Inst{13} = dst{9};
    let Inst{7-1} = dst{8-2};
  }

multiclass JMP_Pred<bit PredNot, string ExtStr> {
  def NAME : T_JMP_c<PredNot, 0, 0, ExtStr>;
  // Predicate new
  def NAME#newpt : T_JMP_c<PredNot, 1, 1, ExtStr>; // taken
  def NAME#new   : T_JMP_c<PredNot, 1, 0, ExtStr>; // not taken
}

multiclass JMP_base<string BaseOp, string ExtStr> {
  let BaseOpcode = BaseOp in {
    def NAME : T_JMP<ExtStr>;
    defm t : JMP_Pred<0, ExtStr>;
    defm f : JMP_Pred<1, ExtStr>;
  }
}

// Jumps to address stored in a register, JUMPR_MISC
// if ([[!]P[.new]]) jumpr[:t/nt] Rs
let isBranch = 1, isIndirectBranch = 1, isBarrier = 1, Defs = [PC],
    isPredicable = 1, hasSideEffects = 0, InputType = "reg" in
class T_JMPr
  : JRInst<(outs), (ins IntRegs:$dst),
      "jumpr $dst", [], "", J_tc_2early_SLOT2> {
    bits<5> dst;

    let IClass = 0b0101;
    let Inst{27-21} = 0b0010100;
    let Inst{20-16} = dst;
}

let isBranch = 1, isIndirectBranch = 1, Defs = [PC], isPredicated = 1,
    hasSideEffects = 0, InputType = "reg" in
class T_JMPr_c <bit PredNot, bit isPredNew, bit isTak>
  : JRInst <(outs), (ins PredRegs:$src, IntRegs:$dst),
      CondStr<"$src", !if(PredNot,0,1), isPredNew>.S #
        JumpOpcStr<"jumpr", isPredNew, isTak>.S # " $dst", [],
      "", J_tc_2early_SLOT2> {

    let isTaken = isTak;
    let isPredicatedFalse = PredNot;
    let isPredicatedNew = isPredNew;
    bits<2> src;
    bits<5> dst;

    let IClass = 0b0101;

    let Inst{27-22} = 0b001101;
    let Inst{21} = PredNot;
    let Inst{20-16} = dst;
    let Inst{12} = !if(isPredNew, isTak, zero);
    let Inst{11} = isPredNew;
    let Inst{9-8} = src;
}

multiclass JMPR_Pred<bit PredNot> {
  def NAME: T_JMPr_c<PredNot, 0, 0>;
  // Predicate new
  def NAME#newpt  : T_JMPr_c<PredNot, 1, 1>; // taken
  def NAME#new    : T_JMPr_c<PredNot, 1, 0>; // not taken
}

multiclass JMPR_base<string BaseOp> {
  let BaseOpcode = BaseOp in {
    def NAME : T_JMPr;
    defm t : JMPR_Pred<0>;
    defm f : JMPR_Pred<1>;
  }
}

let isCall = 1, hasSideEffects = 1 in
class JUMPR_MISC_CALLR<bit isPred, bit isPredNot,
               dag InputDag = (ins IntRegs:$Rs)>
  : JRInst<(outs), InputDag,
      !if(isPred, !if(isPredNot, "if (!$Pu) callr $Rs",
                                 "if ($Pu) callr $Rs"),
                                 "callr $Rs"),
      [], "", J_tc_2early_SLOT2> {
    bits<5> Rs;
    bits<2> Pu;
    let isPredicated = isPred;
    let isPredicatedFalse = isPredNot;

    let IClass = 0b0101;
    let Inst{27-25} = 0b000;
    let Inst{24-23} = !if (isPred, 0b10, 0b01);
    let Inst{22} = 0;
    let Inst{21} = isPredNot;
    let Inst{9-8} = !if (isPred, Pu, 0b00);
    let Inst{20-16} = Rs;

  }

let Defs = VolatileV3.Regs, isCodeGenOnly = 0 in {
  def J2_callrt : JUMPR_MISC_CALLR<1, 0, (ins PredRegs:$Pu, IntRegs:$Rs)>;
  def J2_callrf : JUMPR_MISC_CALLR<1, 1, (ins PredRegs:$Pu, IntRegs:$Rs)>;
}

let isTerminator = 1, hasSideEffects = 0, isCodeGenOnly = 0 in {
  defm J2_jump : JMP_base<"JMP", "">, PredNewRel;

  // Deal with explicit assembly
  //  - never extened a jump #,  always extend a jump ##
  let isAsmParserOnly = 1 in {
    defm J2_jump_ext   : JMP_base<"JMP", "##">;
    defm J2_jump_noext : JMP_base<"JMP", "#">;
  }

  defm J2_jumpr : JMPR_base<"JMPr">, PredNewRel;

  let isReturn = 1, isCodeGenOnly = 1 in
  defm JMPret : JMPR_base<"JMPret">, PredNewRel;
}

def: Pat<(br bb:$dst),
         (J2_jump brtarget:$dst)>;
def: Pat<(retflag),
         (JMPret (i32 R31))>;
def: Pat<(brcond (i1 PredRegs:$src1), bb:$offset),
         (J2_jumpt PredRegs:$src1, bb:$offset)>;

// A return through builtin_eh_return.
let isReturn = 1, isTerminator = 1, isBarrier = 1, hasSideEffects = 0,
    isCodeGenOnly = 1, Defs = [PC], Uses = [R28], isPredicable = 0 in
def EH_RETURN_JMPR : T_JMPr;

def: Pat<(eh_return),
         (EH_RETURN_JMPR (i32 R31))>;
def: Pat<(HexagonBR_JT (i32 IntRegs:$dst)),
         (J2_jumpr IntRegs:$dst)>;
def: Pat<(brind (i32 IntRegs:$dst)),
         (J2_jumpr IntRegs:$dst)>;

//===----------------------------------------------------------------------===//
// JR -
//===----------------------------------------------------------------------===//

//===----------------------------------------------------------------------===//
// LD +
//===----------------------------------------------------------------------===//
///
// Load -- MEMri operand
multiclass LD_MEMri_Pbase<string mnemonic, RegisterClass RC,
                          bit isNot, bit isPredNew> {
  let isPredicatedNew = isPredNew in
  def NAME : LDInst2<(outs RC:$dst),
                       (ins PredRegs:$src1, MEMri:$addr),
            !if(isNot, "if (!$src1", "if ($src1")#!if(isPredNew, ".new) ",
            ") ")#"$dst = "#mnemonic#"($addr)",
            []>;
}

multiclass LD_MEMri_Pred<string mnemonic, RegisterClass RC, bit PredNot> {
  let isPredicatedFalse = PredNot in {
    defm _c#NAME : LD_MEMri_Pbase<mnemonic, RC, PredNot, 0>;
    // Predicate new
    defm _cdn#NAME : LD_MEMri_Pbase<mnemonic, RC, PredNot, 1>;
  }
}

let isExtendable = 1, hasSideEffects = 0 in
multiclass LD_MEMri<string mnemonic, string CextOp, RegisterClass RC,
                    bits<5> ImmBits, bits<5> PredImmBits> {

  let CextOpcode = CextOp, BaseOpcode = CextOp in {
    let opExtendable = 2, isExtentSigned = 1, opExtentBits = ImmBits,
        isPredicable = 1 in
      def NAME : LDInst2<(outs RC:$dst), (ins MEMri:$addr),
                   "$dst = "#mnemonic#"($addr)",
                   []>;

    let opExtendable = 3, isExtentSigned = 0, opExtentBits = PredImmBits,
        isPredicated = 1 in {
      defm Pt : LD_MEMri_Pred<mnemonic, RC, 0 >;
      defm NotPt : LD_MEMri_Pred<mnemonic, RC, 1 >;
    }
  }
}

let addrMode = BaseImmOffset, isMEMri = "true" in {
  let accessSize = ByteAccess in {
    defm LDrib: LD_MEMri < "memb", "LDrib", IntRegs, 11, 6>, AddrModeRel;
    defm LDriub: LD_MEMri < "memub" , "LDriub", IntRegs, 11, 6>, AddrModeRel;
 }

  let accessSize = HalfWordAccess in {
    defm LDrih: LD_MEMri < "memh", "LDrih", IntRegs, 12, 7>, AddrModeRel;
    defm LDriuh: LD_MEMri < "memuh", "LDriuh", IntRegs, 12, 7>, AddrModeRel;
 }

  let accessSize = WordAccess in
    defm LDriw: LD_MEMri < "memw", "LDriw", IntRegs, 13, 8>, AddrModeRel;

  let accessSize = DoubleWordAccess in
    defm LDrid: LD_MEMri < "memd", "LDrid", DoubleRegs, 14, 9>, AddrModeRel;
}

def : Pat < (i32 (sextloadi8 ADDRriS11_0:$addr)),
            (LDrib ADDRriS11_0:$addr) >;

def : Pat < (i32 (zextloadi8 ADDRriS11_0:$addr)),
            (LDriub ADDRriS11_0:$addr) >;

def : Pat < (i32 (sextloadi16 ADDRriS11_1:$addr)),
            (LDrih ADDRriS11_1:$addr) >;

def : Pat < (i32 (zextloadi16 ADDRriS11_1:$addr)),
            (LDriuh ADDRriS11_1:$addr) >;

def : Pat < (i32 (load ADDRriS11_2:$addr)),
            (LDriw ADDRriS11_2:$addr) >;

def : Pat < (i64 (load ADDRriS11_3:$addr)),
            (LDrid ADDRriS11_3:$addr) >;


// Load - Base with Immediate offset addressing mode
multiclass LD_Idxd_Pbase2<string mnemonic, RegisterClass RC, Operand predImmOp,
                        bit isNot, bit isPredNew> {
  let isPredicatedNew = isPredNew in
  def NAME : LDInst2<(outs RC:$dst),
                     (ins PredRegs:$src1, IntRegs:$src2, predImmOp:$src3),
            !if(isNot, "if (!$src1", "if ($src1")#!if(isPredNew, ".new) ",
            ") ")#"$dst = "#mnemonic#"($src2+#$src3)",
            []>;
}

multiclass LD_Idxd_Pred2<string mnemonic, RegisterClass RC, Operand predImmOp,
                        bit PredNot> {
  let isPredicatedFalse = PredNot in {
    defm _c#NAME : LD_Idxd_Pbase2<mnemonic, RC, predImmOp, PredNot, 0>;
    // Predicate new
    defm _cdn#NAME : LD_Idxd_Pbase2<mnemonic, RC, predImmOp, PredNot, 1>;
  }
}

let isExtendable = 1, hasSideEffects = 0 in
multiclass LD_Idxd2<string mnemonic, string CextOp, RegisterClass RC,
                   Operand ImmOp, Operand predImmOp, bits<5> ImmBits,
                   bits<5> PredImmBits> {

  let CextOpcode = CextOp, BaseOpcode = CextOp#_indexed in {
    let opExtendable = 2, isExtentSigned = 1, opExtentBits = ImmBits,
        isPredicable = 1, AddedComplexity = 20 in
      def NAME : LDInst2<(outs RC:$dst), (ins IntRegs:$src1, ImmOp:$offset),
                   "$dst = "#mnemonic#"($src1+#$offset)",
                   []>;

    let opExtendable = 3, isExtentSigned = 0, opExtentBits = PredImmBits,
        isPredicated = 1 in {
      defm Pt : LD_Idxd_Pred2<mnemonic, RC, predImmOp, 0 >;
      defm NotPt : LD_Idxd_Pred2<mnemonic, RC, predImmOp, 1 >;
    }
  }
}

let addrMode = BaseImmOffset in {
  let accessSize = ByteAccess in {
    defm LDrib_indexed: LD_Idxd2 <"memb", "LDrib", IntRegs, s11_0Ext, u6_0Ext,
                                  11, 6>, AddrModeRel;
    defm LDriub_indexed: LD_Idxd2 <"memub" , "LDriub", IntRegs, s11_0Ext, u6_0Ext,
                                   11, 6>, AddrModeRel;
  }
  let accessSize = HalfWordAccess in {
    defm LDrih_indexed: LD_Idxd2 <"memh", "LDrih", IntRegs, s11_1Ext, u6_1Ext,
                                 12, 7>, AddrModeRel;
    defm LDriuh_indexed: LD_Idxd2 <"memuh", "LDriuh", IntRegs, s11_1Ext, u6_1Ext,
                                  12, 7>, AddrModeRel;
  }
  let accessSize = WordAccess in
    defm LDriw_indexed: LD_Idxd2 <"memw", "LDriw", IntRegs, s11_2Ext, u6_2Ext,
                                 13, 8>, AddrModeRel;

  let accessSize = DoubleWordAccess in
    defm LDrid_indexed: LD_Idxd2 <"memd", "LDrid", DoubleRegs, s11_3Ext, u6_3Ext,
                                 14, 9>, AddrModeRel;
}

let AddedComplexity = 20 in {
def : Pat < (i32 (sextloadi8 (add IntRegs:$src1, s11_0ExtPred:$offset))),
            (LDrib_indexed IntRegs:$src1, s11_0ExtPred:$offset) >;

def : Pat < (i32 (zextloadi8 (add IntRegs:$src1, s11_0ExtPred:$offset))),
            (LDriub_indexed IntRegs:$src1, s11_0ExtPred:$offset) >;

def : Pat < (i32 (sextloadi16 (add IntRegs:$src1, s11_1ExtPred:$offset))),
            (LDrih_indexed IntRegs:$src1, s11_1ExtPred:$offset) >;

def : Pat < (i32 (zextloadi16 (add IntRegs:$src1, s11_1ExtPred:$offset))),
            (LDriuh_indexed IntRegs:$src1, s11_1ExtPred:$offset) >;

def : Pat < (i32 (load (add IntRegs:$src1, s11_2ExtPred:$offset))),
            (LDriw_indexed IntRegs:$src1, s11_2ExtPred:$offset) >;

def : Pat < (i64 (load (add IntRegs:$src1, s11_3ExtPred:$offset))),
            (LDrid_indexed IntRegs:$src1, s11_3ExtPred:$offset) >;
}

//===----------------------------------------------------------------------===//
// Post increment load
//===----------------------------------------------------------------------===//

multiclass LD_PostInc_Pbase<string mnemonic, RegisterClass RC, Operand ImmOp,
                            bit isNot, bit isPredNew> {
  let isPredicatedNew = isPredNew in
  def NAME : LDInst2PI<(outs RC:$dst, IntRegs:$dst2),
                       (ins PredRegs:$src1, IntRegs:$src2, ImmOp:$offset),
            !if(isNot, "if (!$src1", "if ($src1")#!if(isPredNew, ".new) ",
            ") ")#"$dst = "#mnemonic#"($src2++#$offset)",
            [],
            "$src2 = $dst2">;
}

multiclass LD_PostInc_Pred<string mnemonic, RegisterClass RC,
                           Operand ImmOp, bit PredNot> {
  let isPredicatedFalse = PredNot in {
    defm _c#NAME : LD_PostInc_Pbase<mnemonic, RC, ImmOp, PredNot, 0>;
    // Predicate new
    let Predicates = [HasV4T], validSubTargets = HasV4SubT in
    defm _cdn#NAME#_V4 : LD_PostInc_Pbase<mnemonic, RC, ImmOp, PredNot, 1>;
  }
}

multiclass LD_PostInc<string mnemonic, string BaseOp, RegisterClass RC,
                      Operand ImmOp> {

  let BaseOpcode = "POST_"#BaseOp in {
    let isPredicable = 1 in
    def NAME : LDInst2PI<(outs RC:$dst, IntRegs:$dst2),
                         (ins IntRegs:$src1, ImmOp:$offset),
                 "$dst = "#mnemonic#"($src1++#$offset)",
                 [],
                 "$src1 = $dst2">;

    let isPredicated = 1 in {
      defm Pt : LD_PostInc_Pred<mnemonic, RC, ImmOp, 0 >;
      defm NotPt : LD_PostInc_Pred<mnemonic, RC, ImmOp, 1 >;
    }
  }
}

let hasCtrlDep = 1, hasSideEffects = 0, addrMode = PostInc in {
  defm POST_LDrib : LD_PostInc<"memb", "LDrib", IntRegs, s4_0Imm>,
                    PredNewRel;
  defm POST_LDriub : LD_PostInc<"memub", "LDriub", IntRegs, s4_0Imm>,
                    PredNewRel;
  defm POST_LDrih : LD_PostInc<"memh", "LDrih", IntRegs, s4_1Imm>,
                    PredNewRel;
  defm POST_LDriuh : LD_PostInc<"memuh", "LDriuh", IntRegs, s4_1Imm>,
                    PredNewRel;
  defm POST_LDriw : LD_PostInc<"memw", "LDriw", IntRegs, s4_2Imm>,
                    PredNewRel;
  defm POST_LDrid : LD_PostInc<"memd", "LDrid", DoubleRegs, s4_3Imm>,
                    PredNewRel;
}

def : Pat< (i32 (extloadi1 ADDRriS11_0:$addr)),
           (i32 (LDrib ADDRriS11_0:$addr)) >;

// Load byte any-extend.
def : Pat < (i32 (extloadi8 ADDRriS11_0:$addr)),
            (i32 (LDrib ADDRriS11_0:$addr)) >;

// Indexed load byte any-extend.
let AddedComplexity = 20 in
def : Pat < (i32 (extloadi8 (add IntRegs:$src1, s11_0ImmPred:$offset))),
            (i32 (LDrib_indexed IntRegs:$src1, s11_0ImmPred:$offset)) >;

def : Pat < (i32 (extloadi16 ADDRriS11_1:$addr)),
            (i32 (LDrih ADDRriS11_1:$addr))>;

let AddedComplexity = 20 in
def : Pat < (i32 (extloadi16 (add IntRegs:$src1, s11_1ImmPred:$offset))),
            (i32 (LDrih_indexed IntRegs:$src1, s11_1ImmPred:$offset)) >;

let AddedComplexity = 10 in
def : Pat < (i32 (zextloadi1 ADDRriS11_0:$addr)),
            (i32 (LDriub ADDRriS11_0:$addr))>;

let AddedComplexity = 20 in
def : Pat < (i32 (zextloadi1 (add IntRegs:$src1, s11_0ImmPred:$offset))),
            (i32 (LDriub_indexed IntRegs:$src1, s11_0ImmPred:$offset))>;

// Load predicate.
let isExtendable = 1, opExtendable = 2, isExtentSigned = 1, opExtentBits = 13,
isPseudo = 1, Defs = [R10,R11,D5], hasSideEffects = 0 in
def LDriw_pred : LDInst2<(outs PredRegs:$dst),
            (ins MEMri:$addr),
            "Error; should not emit",
            []>;

// Deallocate stack frame.
let Defs = [R29, R30, R31], Uses = [R29], hasSideEffects = 0 in {
  def DEALLOCFRAME : LDInst2<(outs), (ins),
                     "deallocframe",
                     []>;
}

// Load and unpack bytes to halfwords.
//===----------------------------------------------------------------------===//
// LD -
//===----------------------------------------------------------------------===//

//===----------------------------------------------------------------------===//
// MTYPE/ALU +
//===----------------------------------------------------------------------===//
//===----------------------------------------------------------------------===//
// MTYPE/ALU -
//===----------------------------------------------------------------------===//

//===----------------------------------------------------------------------===//
// MTYPE/COMPLEX +
//===----------------------------------------------------------------------===//
//===----------------------------------------------------------------------===//
// MTYPE/COMPLEX -
//===----------------------------------------------------------------------===//

//===----------------------------------------------------------------------===//
// MTYPE/MPYH +
//===----------------------------------------------------------------------===//

//===----------------------------------------------------------------------===//
// Template Class
// MPYS / Multipy signed/unsigned halfwords
//Rd=mpy[u](Rs.[H|L],Rt.[H|L])[:<<1][:rnd][:sat]
//===----------------------------------------------------------------------===//

let hasNewValue = 1, opNewValue = 0 in
class T_M2_mpy < bits<2> LHbits, bit isSat, bit isRnd,
                 bit hasShift, bit isUnsigned>
  : MInst < (outs IntRegs:$Rd), (ins IntRegs:$Rs, IntRegs:$Rt),
  "$Rd = "#!if(isUnsigned,"mpyu","mpy")#"($Rs."#!if(LHbits{1},"h","l")
                                       #", $Rt."#!if(LHbits{0},"h)","l)")
                                       #!if(hasShift,":<<1","")
                                       #!if(isRnd,":rnd","")
                                       #!if(isSat,":sat",""),
  [], "", M_tc_3x_SLOT23 > {
    bits<5> Rd;
    bits<5> Rs;
    bits<5> Rt;

    let IClass = 0b1110;

    let Inst{27-24} = 0b1100;
    let Inst{23} = hasShift;
    let Inst{22} = isUnsigned;
    let Inst{21} = isRnd;
    let Inst{7} = isSat;
    let Inst{6-5} = LHbits;
    let Inst{4-0} = Rd;
    let Inst{20-16} = Rs;
    let Inst{12-8} = Rt;
  }

//Rd=mpy(Rs.[H|L],Rt.[H|L])[:<<1]
let isCodeGenOnly = 0 in {
def M2_mpy_ll_s1: T_M2_mpy<0b00, 0, 0, 1, 0>;
def M2_mpy_ll_s0: T_M2_mpy<0b00, 0, 0, 0, 0>;
def M2_mpy_lh_s1: T_M2_mpy<0b01, 0, 0, 1, 0>;
def M2_mpy_lh_s0: T_M2_mpy<0b01, 0, 0, 0, 0>;
def M2_mpy_hl_s1: T_M2_mpy<0b10, 0, 0, 1, 0>;
def M2_mpy_hl_s0: T_M2_mpy<0b10, 0, 0, 0, 0>;
def M2_mpy_hh_s1: T_M2_mpy<0b11, 0, 0, 1, 0>;
def M2_mpy_hh_s0: T_M2_mpy<0b11, 0, 0, 0, 0>;
}

//Rd=mpyu(Rs.[H|L],Rt.[H|L])[:<<1]
let isCodeGenOnly = 0 in {
def M2_mpyu_ll_s1: T_M2_mpy<0b00, 0, 0, 1, 1>;
def M2_mpyu_ll_s0: T_M2_mpy<0b00, 0, 0, 0, 1>;
def M2_mpyu_lh_s1: T_M2_mpy<0b01, 0, 0, 1, 1>;
def M2_mpyu_lh_s0: T_M2_mpy<0b01, 0, 0, 0, 1>;
def M2_mpyu_hl_s1: T_M2_mpy<0b10, 0, 0, 1, 1>;
def M2_mpyu_hl_s0: T_M2_mpy<0b10, 0, 0, 0, 1>;
def M2_mpyu_hh_s1: T_M2_mpy<0b11, 0, 0, 1, 1>;
def M2_mpyu_hh_s0: T_M2_mpy<0b11, 0, 0, 0, 1>;
}

//Rd=mpy(Rs.[H|L],Rt.[H|L])[:<<1]:rnd
let isCodeGenOnly = 0 in {
def M2_mpy_rnd_ll_s1: T_M2_mpy <0b00, 0, 1, 1, 0>;
def M2_mpy_rnd_ll_s0: T_M2_mpy <0b00, 0, 1, 0, 0>;
def M2_mpy_rnd_lh_s1: T_M2_mpy <0b01, 0, 1, 1, 0>;
def M2_mpy_rnd_lh_s0: T_M2_mpy <0b01, 0, 1, 0, 0>;
def M2_mpy_rnd_hl_s1: T_M2_mpy <0b10, 0, 1, 1, 0>;
def M2_mpy_rnd_hl_s0: T_M2_mpy <0b10, 0, 1, 0, 0>;
def M2_mpy_rnd_hh_s1: T_M2_mpy <0b11, 0, 1, 1, 0>;
def M2_mpy_rnd_hh_s0: T_M2_mpy <0b11, 0, 1, 0, 0>;
}

//Rd=mpy(Rs.[H|L],Rt.[H|L])[:<<1][:sat]
//Rd=mpy(Rs.[H|L],Rt.[H|L])[:<<1][:rnd][:sat]
let Defs = [USR_OVF], isCodeGenOnly = 0 in {
  def M2_mpy_sat_ll_s1: T_M2_mpy <0b00, 1, 0, 1, 0>;
  def M2_mpy_sat_ll_s0: T_M2_mpy <0b00, 1, 0, 0, 0>;
  def M2_mpy_sat_lh_s1: T_M2_mpy <0b01, 1, 0, 1, 0>;
  def M2_mpy_sat_lh_s0: T_M2_mpy <0b01, 1, 0, 0, 0>;
  def M2_mpy_sat_hl_s1: T_M2_mpy <0b10, 1, 0, 1, 0>;
  def M2_mpy_sat_hl_s0: T_M2_mpy <0b10, 1, 0, 0, 0>;
  def M2_mpy_sat_hh_s1: T_M2_mpy <0b11, 1, 0, 1, 0>;
  def M2_mpy_sat_hh_s0: T_M2_mpy <0b11, 1, 0, 0, 0>;

  def M2_mpy_sat_rnd_ll_s1: T_M2_mpy <0b00, 1, 1, 1, 0>;
  def M2_mpy_sat_rnd_ll_s0: T_M2_mpy <0b00, 1, 1, 0, 0>;
  def M2_mpy_sat_rnd_lh_s1: T_M2_mpy <0b01, 1, 1, 1, 0>;
  def M2_mpy_sat_rnd_lh_s0: T_M2_mpy <0b01, 1, 1, 0, 0>;
  def M2_mpy_sat_rnd_hl_s1: T_M2_mpy <0b10, 1, 1, 1, 0>;
  def M2_mpy_sat_rnd_hl_s0: T_M2_mpy <0b10, 1, 1, 0, 0>;
  def M2_mpy_sat_rnd_hh_s1: T_M2_mpy <0b11, 1, 1, 1, 0>;
  def M2_mpy_sat_rnd_hh_s0: T_M2_mpy <0b11, 1, 1, 0, 0>;
}

//===----------------------------------------------------------------------===//
// Template Class
// MPYS / Multipy signed/unsigned halfwords and add/subtract the
// result from the accumulator.
//Rx [-+]= mpy[u](Rs.[H|L],Rt.[H|L])[:<<1][:sat]
//===----------------------------------------------------------------------===//

let hasNewValue = 1, opNewValue = 0 in
class T_M2_mpy_acc < bits<2> LHbits, bit isSat, bit isNac,
                 bit hasShift, bit isUnsigned >
  : MInst_acc<(outs IntRegs:$Rx), (ins IntRegs:$dst2, IntRegs:$Rs, IntRegs:$Rt),
  "$Rx "#!if(isNac,"-= ","+= ")#!if(isUnsigned,"mpyu","mpy")
                              #"($Rs."#!if(LHbits{1},"h","l")
                              #", $Rt."#!if(LHbits{0},"h)","l)")
                              #!if(hasShift,":<<1","")
                              #!if(isSat,":sat",""),
  [], "$dst2 = $Rx", M_tc_3x_SLOT23 > {
    bits<5> Rx;
    bits<5> Rs;
    bits<5> Rt;

    let IClass = 0b1110;
    let Inst{27-24} = 0b1110;
    let Inst{23} = hasShift;
    let Inst{22} = isUnsigned;
    let Inst{21} = isNac;
    let Inst{7} = isSat;
    let Inst{6-5} = LHbits;
    let Inst{4-0} = Rx;
    let Inst{20-16} = Rs;
    let Inst{12-8} = Rt;
  }

//Rx += mpy(Rs.[H|L],Rt.[H|L])[:<<1]
let isCodeGenOnly = 0 in {
def M2_mpy_acc_ll_s1: T_M2_mpy_acc <0b00, 0, 0, 1, 0>;
def M2_mpy_acc_ll_s0: T_M2_mpy_acc <0b00, 0, 0, 0, 0>;
def M2_mpy_acc_lh_s1: T_M2_mpy_acc <0b01, 0, 0, 1, 0>;
def M2_mpy_acc_lh_s0: T_M2_mpy_acc <0b01, 0, 0, 0, 0>;
def M2_mpy_acc_hl_s1: T_M2_mpy_acc <0b10, 0, 0, 1, 0>;
def M2_mpy_acc_hl_s0: T_M2_mpy_acc <0b10, 0, 0, 0, 0>;
def M2_mpy_acc_hh_s1: T_M2_mpy_acc <0b11, 0, 0, 1, 0>;
def M2_mpy_acc_hh_s0: T_M2_mpy_acc <0b11, 0, 0, 0, 0>;
}

//Rx += mpyu(Rs.[H|L],Rt.[H|L])[:<<1]
let isCodeGenOnly = 0 in {
def M2_mpyu_acc_ll_s1: T_M2_mpy_acc <0b00, 0, 0, 1, 1>;
def M2_mpyu_acc_ll_s0: T_M2_mpy_acc <0b00, 0, 0, 0, 1>;
def M2_mpyu_acc_lh_s1: T_M2_mpy_acc <0b01, 0, 0, 1, 1>;
def M2_mpyu_acc_lh_s0: T_M2_mpy_acc <0b01, 0, 0, 0, 1>;
def M2_mpyu_acc_hl_s1: T_M2_mpy_acc <0b10, 0, 0, 1, 1>;
def M2_mpyu_acc_hl_s0: T_M2_mpy_acc <0b10, 0, 0, 0, 1>;
def M2_mpyu_acc_hh_s1: T_M2_mpy_acc <0b11, 0, 0, 1, 1>;
def M2_mpyu_acc_hh_s0: T_M2_mpy_acc <0b11, 0, 0, 0, 1>;
}

//Rx -= mpy(Rs.[H|L],Rt.[H|L])[:<<1]
let isCodeGenOnly = 0 in {
def M2_mpy_nac_ll_s1: T_M2_mpy_acc <0b00, 0, 1, 1, 0>;
def M2_mpy_nac_ll_s0: T_M2_mpy_acc <0b00, 0, 1, 0, 0>;
def M2_mpy_nac_lh_s1: T_M2_mpy_acc <0b01, 0, 1, 1, 0>;
def M2_mpy_nac_lh_s0: T_M2_mpy_acc <0b01, 0, 1, 0, 0>;
def M2_mpy_nac_hl_s1: T_M2_mpy_acc <0b10, 0, 1, 1, 0>;
def M2_mpy_nac_hl_s0: T_M2_mpy_acc <0b10, 0, 1, 0, 0>;
def M2_mpy_nac_hh_s1: T_M2_mpy_acc <0b11, 0, 1, 1, 0>;
def M2_mpy_nac_hh_s0: T_M2_mpy_acc <0b11, 0, 1, 0, 0>;
}

//Rx -= mpyu(Rs.[H|L],Rt.[H|L])[:<<1]
let isCodeGenOnly = 0 in {
def M2_mpyu_nac_ll_s1: T_M2_mpy_acc <0b00, 0, 1, 1, 1>;
def M2_mpyu_nac_ll_s0: T_M2_mpy_acc <0b00, 0, 1, 0, 1>;
def M2_mpyu_nac_lh_s1: T_M2_mpy_acc <0b01, 0, 1, 1, 1>;
def M2_mpyu_nac_lh_s0: T_M2_mpy_acc <0b01, 0, 1, 0, 1>;
def M2_mpyu_nac_hl_s1: T_M2_mpy_acc <0b10, 0, 1, 1, 1>;
def M2_mpyu_nac_hl_s0: T_M2_mpy_acc <0b10, 0, 1, 0, 1>;
def M2_mpyu_nac_hh_s1: T_M2_mpy_acc <0b11, 0, 1, 1, 1>;
def M2_mpyu_nac_hh_s0: T_M2_mpy_acc <0b11, 0, 1, 0, 1>;
}

//Rx += mpy(Rs.[H|L],Rt.[H|L])[:<<1]:sat
let isCodeGenOnly = 0 in {
def M2_mpy_acc_sat_ll_s1: T_M2_mpy_acc <0b00, 1, 0, 1, 0>;
def M2_mpy_acc_sat_ll_s0: T_M2_mpy_acc <0b00, 1, 0, 0, 0>;
def M2_mpy_acc_sat_lh_s1: T_M2_mpy_acc <0b01, 1, 0, 1, 0>;
def M2_mpy_acc_sat_lh_s0: T_M2_mpy_acc <0b01, 1, 0, 0, 0>;
def M2_mpy_acc_sat_hl_s1: T_M2_mpy_acc <0b10, 1, 0, 1, 0>;
def M2_mpy_acc_sat_hl_s0: T_M2_mpy_acc <0b10, 1, 0, 0, 0>;
def M2_mpy_acc_sat_hh_s1: T_M2_mpy_acc <0b11, 1, 0, 1, 0>;
def M2_mpy_acc_sat_hh_s0: T_M2_mpy_acc <0b11, 1, 0, 0, 0>;
}

//Rx -= mpy(Rs.[H|L],Rt.[H|L])[:<<1]:sat
let isCodeGenOnly = 0 in {
def M2_mpy_nac_sat_ll_s1: T_M2_mpy_acc <0b00, 1, 1, 1, 0>;
def M2_mpy_nac_sat_ll_s0: T_M2_mpy_acc <0b00, 1, 1, 0, 0>;
def M2_mpy_nac_sat_lh_s1: T_M2_mpy_acc <0b01, 1, 1, 1, 0>;
def M2_mpy_nac_sat_lh_s0: T_M2_mpy_acc <0b01, 1, 1, 0, 0>;
def M2_mpy_nac_sat_hl_s1: T_M2_mpy_acc <0b10, 1, 1, 1, 0>;
def M2_mpy_nac_sat_hl_s0: T_M2_mpy_acc <0b10, 1, 1, 0, 0>;
def M2_mpy_nac_sat_hh_s1: T_M2_mpy_acc <0b11, 1, 1, 1, 0>;
def M2_mpy_nac_sat_hh_s0: T_M2_mpy_acc <0b11, 1, 1, 0, 0>;
}

//===----------------------------------------------------------------------===//
// Template Class
// MPYS / Multipy signed/unsigned halfwords and add/subtract the
// result from the 64-bit destination register.
//Rxx [-+]= mpy[u](Rs.[H|L],Rt.[H|L])[:<<1][:sat]
//===----------------------------------------------------------------------===//

class T_M2_mpyd_acc < bits<2> LHbits, bit isNac, bit hasShift, bit isUnsigned>
  : MInst_acc<(outs DoubleRegs:$Rxx),
              (ins DoubleRegs:$dst2, IntRegs:$Rs, IntRegs:$Rt),
  "$Rxx "#!if(isNac,"-= ","+= ")#!if(isUnsigned,"mpyu","mpy")
                                #"($Rs."#!if(LHbits{1},"h","l")
                                #", $Rt."#!if(LHbits{0},"h)","l)")
                                #!if(hasShift,":<<1",""),
  [], "$dst2 = $Rxx", M_tc_3x_SLOT23 > {
    bits<5> Rxx;
    bits<5> Rs;
    bits<5> Rt;

    let IClass = 0b1110;

    let Inst{27-24} = 0b0110;
    let Inst{23} = hasShift;
    let Inst{22} = isUnsigned;
    let Inst{21} = isNac;
    let Inst{7} = 0;
    let Inst{6-5} = LHbits;
    let Inst{4-0} = Rxx;
    let Inst{20-16} = Rs;
    let Inst{12-8} = Rt;
  }

let isCodeGenOnly = 0 in {
def M2_mpyd_acc_hh_s0: T_M2_mpyd_acc <0b11, 0, 0, 0>;
def M2_mpyd_acc_hl_s0: T_M2_mpyd_acc <0b10, 0, 0, 0>;
def M2_mpyd_acc_lh_s0: T_M2_mpyd_acc <0b01, 0, 0, 0>;
def M2_mpyd_acc_ll_s0: T_M2_mpyd_acc <0b00, 0, 0, 0>;

def M2_mpyd_acc_hh_s1: T_M2_mpyd_acc <0b11, 0, 1, 0>;
def M2_mpyd_acc_hl_s1: T_M2_mpyd_acc <0b10, 0, 1, 0>;
def M2_mpyd_acc_lh_s1: T_M2_mpyd_acc <0b01, 0, 1, 0>;
def M2_mpyd_acc_ll_s1: T_M2_mpyd_acc <0b00, 0, 1, 0>;

def M2_mpyd_nac_hh_s0: T_M2_mpyd_acc <0b11, 1, 0, 0>;
def M2_mpyd_nac_hl_s0: T_M2_mpyd_acc <0b10, 1, 0, 0>;
def M2_mpyd_nac_lh_s0: T_M2_mpyd_acc <0b01, 1, 0, 0>;
def M2_mpyd_nac_ll_s0: T_M2_mpyd_acc <0b00, 1, 0, 0>;

def M2_mpyd_nac_hh_s1: T_M2_mpyd_acc <0b11, 1, 1, 0>;
def M2_mpyd_nac_hl_s1: T_M2_mpyd_acc <0b10, 1, 1, 0>;
def M2_mpyd_nac_lh_s1: T_M2_mpyd_acc <0b01, 1, 1, 0>;
def M2_mpyd_nac_ll_s1: T_M2_mpyd_acc <0b00, 1, 1, 0>;

def M2_mpyud_acc_hh_s0: T_M2_mpyd_acc <0b11, 0, 0, 1>;
def M2_mpyud_acc_hl_s0: T_M2_mpyd_acc <0b10, 0, 0, 1>;
def M2_mpyud_acc_lh_s0: T_M2_mpyd_acc <0b01, 0, 0, 1>;
def M2_mpyud_acc_ll_s0: T_M2_mpyd_acc <0b00, 0, 0, 1>;

def M2_mpyud_acc_hh_s1: T_M2_mpyd_acc <0b11, 0, 1, 1>;
def M2_mpyud_acc_hl_s1: T_M2_mpyd_acc <0b10, 0, 1, 1>;
def M2_mpyud_acc_lh_s1: T_M2_mpyd_acc <0b01, 0, 1, 1>;
def M2_mpyud_acc_ll_s1: T_M2_mpyd_acc <0b00, 0, 1, 1>;

def M2_mpyud_nac_hh_s0: T_M2_mpyd_acc <0b11, 1, 0, 1>;
def M2_mpyud_nac_hl_s0: T_M2_mpyd_acc <0b10, 1, 0, 1>;
def M2_mpyud_nac_lh_s0: T_M2_mpyd_acc <0b01, 1, 0, 1>;
def M2_mpyud_nac_ll_s0: T_M2_mpyd_acc <0b00, 1, 0, 1>;

def M2_mpyud_nac_hh_s1: T_M2_mpyd_acc <0b11, 1, 1, 1>;
def M2_mpyud_nac_hl_s1: T_M2_mpyd_acc <0b10, 1, 1, 1>;
def M2_mpyud_nac_lh_s1: T_M2_mpyd_acc <0b01, 1, 1, 1>;
def M2_mpyud_nac_ll_s1: T_M2_mpyd_acc <0b00, 1, 1, 1>;
}

let hasNewValue = 1, opNewValue = 0 in
class T_MType_mpy <string mnemonic, bits<4> RegTyBits, RegisterClass RC,
                   bits<3> MajOp, bits<3> MinOp, bit isSat = 0, bit isRnd = 0,
                   string op2Suffix = "", bit isRaw = 0, bit isHi = 0 >
  : MInst <(outs IntRegs:$dst), (ins RC:$src1, RC:$src2),
  "$dst = "#mnemonic
           #"($src1, $src2"#op2Suffix#")"
           #!if(MajOp{2}, ":<<1", "")
           #!if(isRnd, ":rnd", "")
           #!if(isSat, ":sat", "")
           #!if(isRaw, !if(isHi, ":raw:hi", ":raw:lo"), ""), [] > {
    bits<5> dst;
    bits<5> src1;
    bits<5> src2;

    let IClass = 0b1110;

    let Inst{27-24} = RegTyBits;
    let Inst{23-21} = MajOp;
    let Inst{20-16} = src1;
    let Inst{13}    = 0b0;
    let Inst{12-8}  = src2;
    let Inst{7-5}   = MinOp;
    let Inst{4-0}   = dst;
  }

class T_MType_dd  <string mnemonic, bits<3> MajOp, bits<3> MinOp,
                   bit isSat = 0, bit isRnd = 0 >
  : T_MType_mpy <mnemonic, 0b1001, DoubleRegs, MajOp, MinOp, isSat, isRnd>;

class T_MType_rr1  <string mnemonic, bits<3> MajOp, bits<3> MinOp,
                    bit isSat = 0, bit isRnd = 0 >
  : T_MType_mpy<mnemonic, 0b1101, IntRegs, MajOp, MinOp, isSat, isRnd>;

class T_MType_rr2 <string mnemonic, bits<3> MajOp, bits<3> MinOp,
                   bit isSat = 0, bit isRnd = 0, string op2str = "" >
  : T_MType_mpy<mnemonic, 0b1101, IntRegs, MajOp, MinOp, isSat, isRnd, op2str>;

let CextOpcode = "mpyi", InputType = "reg", isCodeGenOnly = 0 in
def M2_mpyi    : T_MType_rr1 <"mpyi", 0b000, 0b000>, ImmRegRel;

let isCodeGenOnly = 0 in {
def M2_mpy_up  : T_MType_rr1 <"mpy",  0b000, 0b001>;
def M2_mpyu_up : T_MType_rr1 <"mpyu", 0b010, 0b001>;
}

let isCodeGenOnly = 0 in
def M2_dpmpyss_rnd_s0 : T_MType_rr1 <"mpy", 0b001, 0b001, 0, 1>;

let isCodeGenOnly = 0 in {
def M2_hmmpyh_rs1 : T_MType_rr2 <"mpy", 0b101, 0b100, 1, 1, ".h">;
def M2_hmmpyl_rs1 : T_MType_rr2 <"mpy", 0b111, 0b100, 1, 1, ".l">;
}

// V4 Instructions
let isCodeGenOnly = 0 in {
def M2_mpysu_up : T_MType_rr1 <"mpysu", 0b011, 0b001, 0>;
def M2_mpy_up_s1_sat : T_MType_rr1 <"mpy", 0b111, 0b000, 1>;

def M2_hmmpyh_s1 : T_MType_rr2 <"mpy", 0b101, 0b000, 1, 0, ".h">;
def M2_hmmpyl_s1 : T_MType_rr2 <"mpy", 0b101, 0b001, 1, 0, ".l">;
}

def: Pat<(i32 (mul   I32:$src1, I32:$src2)), (M2_mpyi    I32:$src1, I32:$src2)>;
def: Pat<(i32 (mulhs I32:$src1, I32:$src2)), (M2_mpy_up  I32:$src1, I32:$src2)>;
def: Pat<(i32 (mulhu I32:$src1, I32:$src2)), (M2_mpyu_up I32:$src1, I32:$src2)>;

let hasNewValue = 1, opNewValue = 0 in
class T_MType_mpy_ri <bit isNeg, Operand ImmOp, list<dag> pattern>
  : MInst < (outs IntRegs:$Rd), (ins IntRegs:$Rs, ImmOp:$u8),
  "$Rd ="#!if(isNeg, "- ", "+ ")#"mpyi($Rs, #$u8)" ,
   pattern, "", M_tc_3x_SLOT23> {
    bits<5> Rd;
    bits<5> Rs;
    bits<8> u8;

    let IClass = 0b1110;

    let Inst{27-24} = 0b0000;
    let Inst{23} = isNeg;
    let Inst{13} = 0b0;
    let Inst{4-0} = Rd;
    let Inst{20-16} = Rs;
    let Inst{12-5} = u8;
  }

let isExtendable = 1, opExtentBits = 8, opExtendable = 2, isCodeGenOnly = 0 in
def M2_mpysip : T_MType_mpy_ri <0, u8Ext,
                [(set (i32 IntRegs:$Rd), (mul IntRegs:$Rs, u8ExtPred:$u8))]>;

let isCodeGenOnly = 0 in
def M2_mpysin :  T_MType_mpy_ri <1, u8Imm,
                [(set (i32 IntRegs:$Rd), (ineg (mul IntRegs:$Rs,
                                                    u8ImmPred:$u8)))]>;

// Assember mapped to M2_mpyi
let isAsmParserOnly = 1 in
def M2_mpyui : MInst<(outs IntRegs:$dst),
                     (ins IntRegs:$src1, IntRegs:$src2),
  "$dst = mpyui($src1, $src2)">;

// Rd=mpyi(Rs,#m9)
// s9 is NOT the same as m9 - but it works.. so far.
// Assembler maps to either Rd=+mpyi(Rs,#u8) or Rd=-mpyi(Rs,#u8)
// depending on the value of m9. See Arch Spec.
let isExtendable = 1, opExtendable = 2, isExtentSigned = 1, opExtentBits = 9,
    CextOpcode = "mpyi", InputType = "imm", hasNewValue = 1 in
def M2_mpysmi : MInst<(outs IntRegs:$dst), (ins IntRegs:$src1, s9Ext:$src2),
    "$dst = mpyi($src1, #$src2)",
    [(set (i32 IntRegs:$dst), (mul (i32 IntRegs:$src1),
                                   s9ExtPred:$src2))]>, ImmRegRel;

let hasNewValue = 1, isExtendable = 1,  opExtentBits = 8, opExtendable = 3,
    InputType = "imm" in
class T_MType_acc_ri <string mnemonic, bits<3> MajOp, Operand ImmOp,
                      list<dag> pattern = []>
 : MInst < (outs IntRegs:$dst), (ins IntRegs:$src1, IntRegs:$src2, ImmOp:$src3),
  "$dst "#mnemonic#"($src2, #$src3)",
  pattern, "$src1 = $dst", M_tc_2_SLOT23> {
    bits<5> dst;
    bits<5> src2;
    bits<8> src3;

    let IClass = 0b1110;

    let Inst{27-26} = 0b00;
    let Inst{25-23} = MajOp;
    let Inst{20-16} = src2;
    let Inst{13} = 0b0;
    let Inst{12-5} = src3;
    let Inst{4-0} = dst;
  }

let InputType = "reg", hasNewValue = 1 in
class T_MType_acc_rr <string mnemonic, bits<3> MajOp, bits<3> MinOp,
                      bit isSwap = 0, list<dag> pattern = [], bit hasNot = 0,
                      bit isSat = 0, bit isShift = 0>
  : MInst < (outs IntRegs:$dst),
            (ins IntRegs:$src1, IntRegs:$src2, IntRegs:$src3),
  "$dst "#mnemonic#"($src2, "#!if(hasNot, "~$src3)","$src3)")
                          #!if(isShift, ":<<1", "")
                          #!if(isSat, ":sat", ""),
  pattern, "$src1 = $dst", M_tc_2_SLOT23 > {
    bits<5> dst;
    bits<5> src2;
    bits<5> src3;

    let IClass = 0b1110;

    let Inst{27-24} = 0b1111;
    let Inst{23-21} = MajOp;
    let Inst{20-16} = !if(isSwap, src3, src2);
    let Inst{13} = 0b0;
    let Inst{12-8} = !if(isSwap, src2, src3);
    let Inst{7-5} = MinOp;
    let Inst{4-0} = dst;
  }

let CextOpcode = "MPYI_acc", Itinerary = M_tc_3x_SLOT23, isCodeGenOnly = 0 in {
  def M2_macsip : T_MType_acc_ri <"+= mpyi", 0b010, u8Ext,
                  [(set (i32 IntRegs:$dst),
                        (add (mul IntRegs:$src2, u8ExtPred:$src3),
                             IntRegs:$src1))]>, ImmRegRel;

  def M2_maci   : T_MType_acc_rr <"+= mpyi", 0b000, 0b000, 0,
                 [(set (i32 IntRegs:$dst),
                       (add (mul IntRegs:$src2, IntRegs:$src3),
                            IntRegs:$src1))]>, ImmRegRel;
}

let CextOpcode = "ADD_acc", isCodeGenOnly = 0 in {
  let isExtentSigned = 1 in
  def M2_accii : T_MType_acc_ri <"+= add", 0b100, s8Ext,
                 [(set (i32 IntRegs:$dst),
                       (add (add (i32 IntRegs:$src2), s8_16ExtPred:$src3),
                            (i32 IntRegs:$src1)))]>, ImmRegRel;

  def M2_acci  : T_MType_acc_rr <"+= add",  0b000, 0b001, 0,
                 [(set (i32 IntRegs:$dst),
                       (add (add (i32 IntRegs:$src2), (i32 IntRegs:$src3)),
                            (i32 IntRegs:$src1)))]>, ImmRegRel;
}

let CextOpcode = "SUB_acc", isCodeGenOnly = 0 in {
  let isExtentSigned = 1 in
  def M2_naccii : T_MType_acc_ri <"-= add", 0b101, s8Ext>, ImmRegRel;

  def M2_nacci  : T_MType_acc_rr <"-= add",  0b100, 0b001, 0>, ImmRegRel;
}

let Itinerary = M_tc_3x_SLOT23, isCodeGenOnly = 0 in
def M2_macsin : T_MType_acc_ri <"-= mpyi", 0b011, u8Ext>;

let isCodeGenOnly = 0 in {
def M2_xor_xacc : T_MType_acc_rr < "^= xor", 0b100, 0b011, 0>;
def M2_subacc : T_MType_acc_rr <"+= sub",  0b000, 0b011, 1>;
}

class T_MType_acc_pat1 <InstHexagon MI, SDNode firstOp, SDNode secOp,
                        PatLeaf ImmPred>
  : Pat <(secOp IntRegs:$src1, (firstOp IntRegs:$src2, ImmPred:$src3)),
         (MI IntRegs:$src1, IntRegs:$src2, ImmPred:$src3)>;

class T_MType_acc_pat2 <InstHexagon MI, SDNode firstOp, SDNode secOp>
  : Pat <(i32 (secOp IntRegs:$src1, (firstOp IntRegs:$src2, IntRegs:$src3))),
         (MI IntRegs:$src1, IntRegs:$src2, IntRegs:$src3)>;

def : T_MType_acc_pat2 <M2_xor_xacc, xor, xor>;
def : T_MType_acc_pat1 <M2_macsin, mul, sub, u8ExtPred>;

def : T_MType_acc_pat1 <M2_naccii, add, sub, s8_16ExtPred>;
def : T_MType_acc_pat2 <M2_nacci, add, sub>;
//===----------------------------------------------------------------------===//
// Template Class -- Multiply signed/unsigned halfwords with and without
// saturation and rounding
//===----------------------------------------------------------------------===//
class T_M2_mpyd < bits<2> LHbits, bit isRnd, bit hasShift, bit isUnsigned >
  : MInst < (outs DoubleRegs:$Rdd), (ins IntRegs:$Rs, IntRegs:$Rt),
  "$Rdd = "#!if(isUnsigned,"mpyu","mpy")#"($Rs."#!if(LHbits{1},"h","l")
                                       #", $Rt."#!if(LHbits{0},"h)","l)")
                                       #!if(hasShift,":<<1","")
                                       #!if(isRnd,":rnd",""),
  [] > {
    bits<5> Rdd;
    bits<5> Rs;
    bits<5> Rt;

    let IClass = 0b1110;

    let Inst{27-24} = 0b0100;
    let Inst{23} = hasShift;
    let Inst{22} = isUnsigned;
    let Inst{21} = isRnd;
    let Inst{6-5} = LHbits;
    let Inst{4-0} = Rdd;
    let Inst{20-16} = Rs;
    let Inst{12-8} = Rt;
}

let isCodeGenOnly = 0 in {
def M2_mpyd_hh_s0: T_M2_mpyd<0b11, 0, 0, 0>;
def M2_mpyd_hl_s0: T_M2_mpyd<0b10, 0, 0, 0>;
def M2_mpyd_lh_s0: T_M2_mpyd<0b01, 0, 0, 0>;
def M2_mpyd_ll_s0: T_M2_mpyd<0b00, 0, 0, 0>;

def M2_mpyd_hh_s1: T_M2_mpyd<0b11, 0, 1, 0>;
def M2_mpyd_hl_s1: T_M2_mpyd<0b10, 0, 1, 0>;
def M2_mpyd_lh_s1: T_M2_mpyd<0b01, 0, 1, 0>;
def M2_mpyd_ll_s1: T_M2_mpyd<0b00, 0, 1, 0>;

def M2_mpyd_rnd_hh_s0: T_M2_mpyd<0b11, 1, 0, 0>;
def M2_mpyd_rnd_hl_s0: T_M2_mpyd<0b10, 1, 0, 0>;
def M2_mpyd_rnd_lh_s0: T_M2_mpyd<0b01, 1, 0, 0>;
def M2_mpyd_rnd_ll_s0: T_M2_mpyd<0b00, 1, 0, 0>;

def M2_mpyd_rnd_hh_s1: T_M2_mpyd<0b11, 1, 1, 0>;
def M2_mpyd_rnd_hl_s1: T_M2_mpyd<0b10, 1, 1, 0>;
def M2_mpyd_rnd_lh_s1: T_M2_mpyd<0b01, 1, 1, 0>;
def M2_mpyd_rnd_ll_s1: T_M2_mpyd<0b00, 1, 1, 0>;

//Rdd=mpyu(Rs.[HL],Rt.[HL])[:<<1]
def M2_mpyud_hh_s0: T_M2_mpyd<0b11, 0, 0, 1>;
def M2_mpyud_hl_s0: T_M2_mpyd<0b10, 0, 0, 1>;
def M2_mpyud_lh_s0: T_M2_mpyd<0b01, 0, 0, 1>;
def M2_mpyud_ll_s0: T_M2_mpyd<0b00, 0, 0, 1>;

def M2_mpyud_hh_s1: T_M2_mpyd<0b11, 0, 1, 1>;
def M2_mpyud_hl_s1: T_M2_mpyd<0b10, 0, 1, 1>;
def M2_mpyud_lh_s1: T_M2_mpyd<0b01, 0, 1, 1>;
def M2_mpyud_ll_s1: T_M2_mpyd<0b00, 0, 1, 1>;
}
//===----------------------------------------------------------------------===//
// Template Class for xtype mpy:
// Vector multiply
// Complex multiply
// multiply 32X32 and use full result
//===----------------------------------------------------------------------===//
let hasSideEffects = 0 in
class T_XTYPE_mpy64 <string mnemonic, bits<3> MajOp, bits<3> MinOp,
                     bit isSat, bit hasShift, bit isConj>
   : MInst <(outs DoubleRegs:$Rdd),
            (ins IntRegs:$Rs, IntRegs:$Rt),
  "$Rdd = "#mnemonic#"($Rs, $Rt"#!if(isConj,"*)",")")
                                #!if(hasShift,":<<1","")
                                #!if(isSat,":sat",""),
  [] > {
    bits<5> Rdd;
    bits<5> Rs;
    bits<5> Rt;

    let IClass = 0b1110;

    let Inst{27-24} = 0b0101;
    let Inst{23-21} = MajOp;
    let Inst{20-16} = Rs;
    let Inst{12-8} = Rt;
    let Inst{7-5} = MinOp;
    let Inst{4-0} = Rdd;
  }

//===----------------------------------------------------------------------===//
// Template Class for xtype mpy with accumulation into 64-bit:
// Vector multiply
// Complex multiply
// multiply 32X32 and use full result
//===----------------------------------------------------------------------===//
class T_XTYPE_mpy64_acc <string op1, string op2, bits<3> MajOp, bits<3> MinOp,
                         bit isSat, bit hasShift, bit isConj>
  : MInst <(outs DoubleRegs:$Rxx),
           (ins DoubleRegs:$dst2, IntRegs:$Rs, IntRegs:$Rt),
  "$Rxx "#op2#"= "#op1#"($Rs, $Rt"#!if(isConj,"*)",")")
                                   #!if(hasShift,":<<1","")
                                   #!if(isSat,":sat",""),

  [] , "$dst2 = $Rxx" > {
    bits<5> Rxx;
    bits<5> Rs;
    bits<5> Rt;

    let IClass = 0b1110;

    let Inst{27-24} = 0b0111;
    let Inst{23-21} = MajOp;
    let Inst{20-16} = Rs;
    let Inst{12-8} = Rt;
    let Inst{7-5} = MinOp;
    let Inst{4-0} = Rxx;
  }

// MPY - Multiply and use full result
// Rdd = mpy[u](Rs,Rt)
let isCodeGenOnly = 0 in {
def M2_dpmpyss_s0 : T_XTYPE_mpy64 < "mpy", 0b000, 0b000, 0, 0, 0>;
def M2_dpmpyuu_s0 : T_XTYPE_mpy64 < "mpyu", 0b010, 0b000, 0, 0, 0>;

// Rxx[+-]= mpy[u](Rs,Rt)
def M2_dpmpyss_acc_s0 : T_XTYPE_mpy64_acc < "mpy",  "+", 0b000, 0b000, 0, 0, 0>;
def M2_dpmpyss_nac_s0 : T_XTYPE_mpy64_acc < "mpy",  "-", 0b001, 0b000, 0, 0, 0>;
def M2_dpmpyuu_acc_s0 : T_XTYPE_mpy64_acc < "mpyu", "+", 0b010, 0b000, 0, 0, 0>;
def M2_dpmpyuu_nac_s0 : T_XTYPE_mpy64_acc < "mpyu", "-", 0b011, 0b000, 0, 0, 0>;
}

def: Pat<(i64 (mul (i64 (anyext (i32 IntRegs:$src1))),
                   (i64 (anyext (i32 IntRegs:$src2))))),
         (M2_dpmpyuu_s0 IntRegs:$src1, IntRegs:$src2)>;

def: Pat<(i64 (mul (i64 (sext (i32 IntRegs:$src1))),
                   (i64 (sext (i32 IntRegs:$src2))))),
         (M2_dpmpyss_s0 IntRegs:$src1, IntRegs:$src2)>;

def: Pat<(i64 (mul (is_sext_i32:$src1),
                   (is_sext_i32:$src2))),
         (M2_dpmpyss_s0 (LoReg DoubleRegs:$src1), (LoReg DoubleRegs:$src2))>;

// Multiply and accumulate, use full result.
// Rxx[+-]=mpy(Rs,Rt)

def: Pat<(i64 (add (i64 DoubleRegs:$src1),
                   (mul (i64 (sext (i32 IntRegs:$src2))),
                        (i64 (sext (i32 IntRegs:$src3)))))),
         (M2_dpmpyss_acc_s0 DoubleRegs:$src1, IntRegs:$src2, IntRegs:$src3)>;

def: Pat<(i64 (sub (i64 DoubleRegs:$src1),
                   (mul (i64 (sext (i32 IntRegs:$src2))),
                        (i64 (sext (i32 IntRegs:$src3)))))),
         (M2_dpmpyss_nac_s0 DoubleRegs:$src1, IntRegs:$src2, IntRegs:$src3)>;

def: Pat<(i64 (add (i64 DoubleRegs:$src1),
                   (mul (i64 (anyext (i32 IntRegs:$src2))),
                        (i64 (anyext (i32 IntRegs:$src3)))))),
         (M2_dpmpyuu_acc_s0 DoubleRegs:$src1, IntRegs:$src2, IntRegs:$src3)>;

def: Pat<(i64 (add (i64 DoubleRegs:$src1),
                   (mul (i64 (zext (i32 IntRegs:$src2))),
                        (i64 (zext (i32 IntRegs:$src3)))))),
         (M2_dpmpyuu_acc_s0 DoubleRegs:$src1, IntRegs:$src2, IntRegs:$src3)>;

def: Pat<(i64 (sub (i64 DoubleRegs:$src1),
                   (mul (i64 (anyext (i32 IntRegs:$src2))),
                        (i64 (anyext (i32 IntRegs:$src3)))))),
         (M2_dpmpyuu_nac_s0 DoubleRegs:$src1, IntRegs:$src2, IntRegs:$src3)>;

def: Pat<(i64 (sub (i64 DoubleRegs:$src1),
                   (mul (i64 (zext (i32 IntRegs:$src2))),
                        (i64 (zext (i32 IntRegs:$src3)))))),
         (M2_dpmpyuu_nac_s0 DoubleRegs:$src1, IntRegs:$src2, IntRegs:$src3)>;

//===----------------------------------------------------------------------===//
// MTYPE/MPYH -
//===----------------------------------------------------------------------===//

//===----------------------------------------------------------------------===//
// MTYPE/MPYS +
//===----------------------------------------------------------------------===//
//===----------------------------------------------------------------------===//
// MTYPE/MPYS -
//===----------------------------------------------------------------------===//

//===----------------------------------------------------------------------===//
// MTYPE/VB +
//===----------------------------------------------------------------------===//
//===----------------------------------------------------------------------===//
// MTYPE/VB -
//===----------------------------------------------------------------------===//

//===----------------------------------------------------------------------===//
// MTYPE/VH  +
//===----------------------------------------------------------------------===//
//===----------------------------------------------------------------------===//
// MTYPE/VH  -
//===----------------------------------------------------------------------===//

//===----------------------------------------------------------------------===//
// ST +
//===----------------------------------------------------------------------===//
///
// Store doubleword.

//===----------------------------------------------------------------------===//
// Post increment store
//===----------------------------------------------------------------------===//

multiclass ST_PostInc_Pbase<string mnemonic, RegisterClass RC, Operand ImmOp,
                            bit isNot, bit isPredNew> {
  let isPredicatedNew = isPredNew in
  def NAME : STInst2PI<(outs IntRegs:$dst),
            (ins PredRegs:$src1, IntRegs:$src2, ImmOp:$offset, RC:$src3),
            !if(isNot, "if (!$src1", "if ($src1")#!if(isPredNew, ".new) ",
            ") ")#mnemonic#"($src2++#$offset) = $src3",
            [],
            "$src2 = $dst">;
}

multiclass ST_PostInc_Pred<string mnemonic, RegisterClass RC,
                           Operand ImmOp, bit PredNot> {
  let isPredicatedFalse = PredNot in {
    defm _c#NAME : ST_PostInc_Pbase<mnemonic, RC, ImmOp, PredNot, 0>;
    // Predicate new
    let Predicates = [HasV4T], validSubTargets = HasV4SubT in
    defm _cdn#NAME#_V4 : ST_PostInc_Pbase<mnemonic, RC, ImmOp, PredNot, 1>;
  }
}

let hasCtrlDep = 1, isNVStorable = 1, hasSideEffects = 0 in
multiclass ST_PostInc<string mnemonic, string BaseOp, RegisterClass RC,
                      Operand ImmOp> {

  let hasCtrlDep = 1, BaseOpcode = "POST_"#BaseOp in {
    let isPredicable = 1 in
    def NAME : STInst2PI<(outs IntRegs:$dst),
                (ins IntRegs:$src1, ImmOp:$offset, RC:$src2),
                mnemonic#"($src1++#$offset) = $src2",
                [],
                "$src1 = $dst">;

    let isPredicated = 1 in {
      defm Pt : ST_PostInc_Pred<mnemonic, RC, ImmOp, 0 >;
      defm NotPt : ST_PostInc_Pred<mnemonic, RC, ImmOp, 1 >;
    }
  }
}

defm POST_STbri: ST_PostInc <"memb", "STrib", IntRegs, s4_0Imm>, AddrModeRel;
defm POST_SThri: ST_PostInc <"memh", "STrih", IntRegs, s4_1Imm>, AddrModeRel;
defm POST_STwri: ST_PostInc <"memw", "STriw", IntRegs, s4_2Imm>, AddrModeRel;

let isNVStorable = 0 in
defm POST_STdri: ST_PostInc <"memd", "STrid", DoubleRegs, s4_3Imm>, AddrModeRel;

def : Pat<(post_truncsti8 (i32 IntRegs:$src1), IntRegs:$src2,
                           s4_3ImmPred:$offset),
          (POST_STbri IntRegs:$src2, s4_0ImmPred:$offset, IntRegs:$src1)>;

def : Pat<(post_truncsti16 (i32 IntRegs:$src1), IntRegs:$src2,
                            s4_3ImmPred:$offset),
          (POST_SThri IntRegs:$src2, s4_1ImmPred:$offset, IntRegs:$src1)>;

def : Pat<(post_store (i32 IntRegs:$src1), IntRegs:$src2, s4_2ImmPred:$offset),
          (POST_STwri IntRegs:$src2, s4_1ImmPred:$offset, IntRegs:$src1)>;

def : Pat<(post_store (i64 DoubleRegs:$src1), IntRegs:$src2,
                       s4_3ImmPred:$offset),
          (POST_STdri IntRegs:$src2, s4_3ImmPred:$offset, DoubleRegs:$src1)>;

//===----------------------------------------------------------------------===//
// multiclass for the store instructions with MEMri operand.
//===----------------------------------------------------------------------===//
multiclass ST_MEMri_Pbase<string mnemonic, RegisterClass RC, bit isNot,
                          bit isPredNew> {
  let isPredicatedNew = isPredNew in
  def NAME : STInst2<(outs),
            (ins PredRegs:$src1, MEMri:$addr, RC: $src2),
            !if(isNot, "if (!$src1", "if ($src1")#!if(isPredNew, ".new) ",
            ") ")#mnemonic#"($addr) = $src2",
            []>;
}

multiclass ST_MEMri_Pred<string mnemonic, RegisterClass RC, bit PredNot> {
  let isPredicatedFalse = PredNot in {
    defm _c#NAME : ST_MEMri_Pbase<mnemonic, RC, PredNot, 0>;

    // Predicate new
    let validSubTargets = HasV4SubT, Predicates = [HasV4T] in
    defm _cdn#NAME#_V4 : ST_MEMri_Pbase<mnemonic, RC, PredNot, 1>;
  }
}

let isExtendable = 1, isNVStorable = 1, hasSideEffects = 0 in
multiclass ST_MEMri<string mnemonic, string CextOp, RegisterClass RC,
                    bits<5> ImmBits, bits<5> PredImmBits> {

  let CextOpcode = CextOp, BaseOpcode = CextOp in {
    let opExtendable = 1, isExtentSigned = 1, opExtentBits = ImmBits,
         isPredicable = 1 in
    def NAME : STInst2<(outs),
            (ins MEMri:$addr, RC:$src),
            mnemonic#"($addr) = $src",
            []>;

    let opExtendable = 2, isExtentSigned = 0, opExtentBits = PredImmBits,
        isPredicated = 1 in {
      defm Pt : ST_MEMri_Pred<mnemonic, RC, 0>;
      defm NotPt : ST_MEMri_Pred<mnemonic, RC, 1>;
    }
  }
}

let addrMode = BaseImmOffset, isMEMri = "true" in {
  let accessSize = ByteAccess in
    defm STrib: ST_MEMri < "memb", "STrib", IntRegs, 11, 6>, AddrModeRel;

  let accessSize = HalfWordAccess in
    defm STrih: ST_MEMri < "memh", "STrih", IntRegs, 12, 7>, AddrModeRel;

  let accessSize = WordAccess in
    defm STriw: ST_MEMri < "memw", "STriw", IntRegs, 13, 8>, AddrModeRel;

  let accessSize = DoubleWordAccess, isNVStorable = 0 in
    defm STrid: ST_MEMri < "memd", "STrid", DoubleRegs, 14, 9>, AddrModeRel;
}

def : Pat<(truncstorei8 (i32 IntRegs:$src1), ADDRriS11_0:$addr),
          (STrib ADDRriS11_0:$addr, (i32 IntRegs:$src1))>;

def : Pat<(truncstorei16 (i32 IntRegs:$src1), ADDRriS11_1:$addr),
          (STrih ADDRriS11_1:$addr, (i32 IntRegs:$src1))>;

def : Pat<(store (i32 IntRegs:$src1), ADDRriS11_2:$addr),
          (STriw ADDRriS11_2:$addr, (i32 IntRegs:$src1))>;

def : Pat<(store (i64 DoubleRegs:$src1), ADDRriS11_3:$addr),
          (STrid ADDRriS11_3:$addr, (i64 DoubleRegs:$src1))>;


//===----------------------------------------------------------------------===//
// multiclass for the store instructions with base+immediate offset
// addressing mode
//===----------------------------------------------------------------------===//
multiclass ST_Idxd_Pbase<string mnemonic, RegisterClass RC, Operand predImmOp,
                        bit isNot, bit isPredNew> {
  let isPredicatedNew = isPredNew in
  def NAME : STInst2<(outs),
            (ins PredRegs:$src1, IntRegs:$src2, predImmOp:$src3, RC: $src4),
            !if(isNot, "if (!$src1", "if ($src1")#!if(isPredNew, ".new) ",
            ") ")#mnemonic#"($src2+#$src3) = $src4",
            []>;
}

multiclass ST_Idxd_Pred<string mnemonic, RegisterClass RC, Operand predImmOp,
                        bit PredNot> {
  let isPredicatedFalse = PredNot, isPredicated = 1 in {
    defm _c#NAME : ST_Idxd_Pbase<mnemonic, RC, predImmOp, PredNot, 0>;

    // Predicate new
    let validSubTargets = HasV4SubT, Predicates = [HasV4T] in
    defm _cdn#NAME#_V4 : ST_Idxd_Pbase<mnemonic, RC, predImmOp, PredNot, 1>;
  }
}

let isExtendable = 1, isNVStorable = 1, hasSideEffects = 0 in
multiclass ST_Idxd<string mnemonic, string CextOp, RegisterClass RC,
                   Operand ImmOp, Operand predImmOp, bits<5> ImmBits,
                   bits<5> PredImmBits> {

  let CextOpcode = CextOp, BaseOpcode = CextOp#_indexed in {
    let opExtendable = 1, isExtentSigned = 1, opExtentBits = ImmBits,
         isPredicable = 1 in
    def NAME : STInst2<(outs),
            (ins IntRegs:$src1, ImmOp:$src2, RC:$src3),
            mnemonic#"($src1+#$src2) = $src3",
            []>;

    let opExtendable = 2, isExtentSigned = 0, opExtentBits = PredImmBits in {
      defm Pt : ST_Idxd_Pred<mnemonic, RC, predImmOp, 0>;
      defm NotPt : ST_Idxd_Pred<mnemonic, RC, predImmOp, 1>;
    }
  }
}

let addrMode = BaseImmOffset, InputType = "reg" in {
  let accessSize = ByteAccess in
    defm STrib_indexed: ST_Idxd < "memb", "STrib", IntRegs, s11_0Ext,
                                  u6_0Ext, 11, 6>, AddrModeRel, ImmRegRel;

  let accessSize = HalfWordAccess in
    defm STrih_indexed: ST_Idxd < "memh", "STrih", IntRegs, s11_1Ext,
                                  u6_1Ext, 12, 7>, AddrModeRel, ImmRegRel;

  let accessSize = WordAccess in
    defm STriw_indexed: ST_Idxd < "memw", "STriw", IntRegs, s11_2Ext,
                                  u6_2Ext, 13, 8>, AddrModeRel, ImmRegRel;

  let accessSize = DoubleWordAccess, isNVStorable = 0 in
    defm STrid_indexed: ST_Idxd < "memd", "STrid", DoubleRegs, s11_3Ext,
                                  u6_3Ext, 14, 9>, AddrModeRel;
}

let AddedComplexity = 10 in {
def : Pat<(truncstorei8 (i32 IntRegs:$src1), (add IntRegs:$src2,
                                                  s11_0ExtPred:$offset)),
          (STrib_indexed IntRegs:$src2, s11_0ImmPred:$offset,
                         (i32 IntRegs:$src1))>;

def : Pat<(truncstorei16 (i32 IntRegs:$src1), (add IntRegs:$src2,
                                                   s11_1ExtPred:$offset)),
          (STrih_indexed IntRegs:$src2, s11_1ImmPred:$offset,
                         (i32 IntRegs:$src1))>;

def : Pat<(store (i32 IntRegs:$src1), (add IntRegs:$src2,
                                           s11_2ExtPred:$offset)),
          (STriw_indexed IntRegs:$src2, s11_2ImmPred:$offset,
                         (i32 IntRegs:$src1))>;

def : Pat<(store (i64 DoubleRegs:$src1), (add IntRegs:$src2,
                                              s11_3ExtPred:$offset)),
          (STrid_indexed IntRegs:$src2, s11_3ImmPred:$offset,
                         (i64 DoubleRegs:$src1))>;
}

// memh(Rx++#s4:1)=Rt.H

// Store word.
// Store predicate.
let Defs = [R10,R11,D5], hasSideEffects = 0 in
def STriw_pred : STInst2<(outs),
            (ins MEMri:$addr, PredRegs:$src1),
            "Error; should not emit",
            []>;

// Allocate stack frame.
let Defs = [R29, R30], Uses = [R31, R30], hasSideEffects = 0 in {
  def ALLOCFRAME : STInst2<(outs),
             (ins i32imm:$amt),
             "allocframe(#$amt)",
             []>;
}
//===----------------------------------------------------------------------===//
// ST -
//===----------------------------------------------------------------------===//

//===----------------------------------------------------------------------===//
// STYPE/ALU +
//===----------------------------------------------------------------------===//
// Logical NOT.
def NOT_rr64 : ALU64_rr<(outs DoubleRegs:$dst), (ins DoubleRegs:$src1),
               "$dst = not($src1)",
               [(set (i64 DoubleRegs:$dst), (not (i64 DoubleRegs:$src1)))]>;


//===----------------------------------------------------------------------===//
// STYPE/ALU -
//===----------------------------------------------------------------------===//

let hasSideEffects = 0 in
class T_S2op_1 <string mnemonic, bits<4> RegTyBits, RegisterClass RCOut,
                RegisterClass RCIn, bits<2> MajOp, bits<3> MinOp, bit isSat>
  : SInst <(outs RCOut:$dst), (ins RCIn:$src),
  "$dst = "#mnemonic#"($src)"#!if(isSat, ":sat", ""),
  [], "", S_2op_tc_1_SLOT23 > {
    bits<5> dst;
    bits<5> src;

    let IClass = 0b1000;

    let Inst{27-24} = RegTyBits;
    let Inst{23-22} = MajOp;
    let Inst{21} = 0b0;
    let Inst{20-16} = src;
    let Inst{7-5} = MinOp;
    let Inst{4-0} = dst;
  }

class T_S2op_1_di <string mnemonic, bits<2> MajOp, bits<3> MinOp>
  : T_S2op_1 <mnemonic, 0b0100, DoubleRegs, IntRegs, MajOp, MinOp, 0>;

let hasNewValue = 1 in
class T_S2op_1_id <string mnemonic, bits<2> MajOp, bits<3> MinOp, bit isSat = 0>
  : T_S2op_1 <mnemonic, 0b1000, IntRegs, DoubleRegs, MajOp, MinOp, isSat>;

let hasNewValue = 1 in
class T_S2op_1_ii <string mnemonic, bits<2> MajOp, bits<3> MinOp, bit isSat = 0>
  : T_S2op_1 <mnemonic, 0b1100, IntRegs, IntRegs, MajOp, MinOp, isSat>;

// Sign extend word to doubleword
let isCodeGenOnly = 0 in
def A2_sxtw   : T_S2op_1_di <"sxtw", 0b01, 0b000>;

def: Pat <(i64 (sext I32:$src)), (A2_sxtw I32:$src)>;

// Swizzle the bytes of a word
let isCodeGenOnly = 0 in
def A2_swiz : T_S2op_1_ii <"swiz", 0b10, 0b111>;

// Saturate
let Defs = [USR_OVF], isCodeGenOnly = 0 in {
  def A2_sat   : T_S2op_1_id <"sat", 0b11, 0b000>;
  def A2_satb  : T_S2op_1_ii <"satb", 0b11, 0b111>;
  def A2_satub : T_S2op_1_ii <"satub", 0b11, 0b110>;
  def A2_sath  : T_S2op_1_ii <"sath", 0b11, 0b100>;
  def A2_satuh : T_S2op_1_ii <"satuh", 0b11, 0b101>;
}

let Itinerary = S_2op_tc_2_SLOT23, isCodeGenOnly = 0 in {
  // Absolute value word
  def A2_abs    : T_S2op_1_ii <"abs", 0b10, 0b100>;

  let Defs = [USR_OVF] in
  def A2_abssat : T_S2op_1_ii <"abs", 0b10, 0b101, 1>;

  // Negate with saturation
  let Defs = [USR_OVF] in
  def A2_negsat : T_S2op_1_ii <"neg", 0b10, 0b110, 1>;
}

def: Pat<(i32 (select (i1 (setlt (i32 IntRegs:$src), 0)),
                      (i32 (sub 0, (i32 IntRegs:$src))),
                      (i32 IntRegs:$src))),
         (A2_abs IntRegs:$src)>;

let AddedComplexity = 50 in
def: Pat<(i32 (xor (add (sra (i32 IntRegs:$src), (i32 31)),
                        (i32 IntRegs:$src)),
                   (sra (i32 IntRegs:$src), (i32 31)))),
         (A2_abs IntRegs:$src)>;

class T_S2op_2 <string mnemonic, bits<4> RegTyBits, RegisterClass RCOut,
                RegisterClass RCIn, bits<3> MajOp, bits<3> MinOp,
                bit isSat, bit isRnd, list<dag> pattern = []>
  : SInst <(outs RCOut:$dst),
  (ins RCIn:$src, u5Imm:$u5),
  "$dst = "#mnemonic#"($src, #$u5)"#!if(isSat, ":sat", "")
                                   #!if(isRnd, ":rnd", ""),
  pattern, "", S_2op_tc_2_SLOT23> {
    bits<5> dst;
    bits<5> src;
    bits<5> u5;

    let IClass = 0b1000;

    let Inst{27-24} = RegTyBits;
    let Inst{23-21} = MajOp;
    let Inst{20-16} = src;
    let Inst{13} = 0b0;
    let Inst{12-8} = u5;
    let Inst{7-5} = MinOp;
    let Inst{4-0} = dst;
  }
  
let hasNewValue = 1 in
class T_S2op_2_ii <string mnemonic, bits<3> MajOp, bits<3> MinOp,
                   bit isSat = 0, bit isRnd = 0, list<dag> pattern = []>
  : T_S2op_2 <mnemonic, 0b1100, IntRegs, IntRegs, MajOp, MinOp,
              isSat, isRnd, pattern>;

class T_S2op_shift <string mnemonic, bits<3> MajOp, bits<3> MinOp, SDNode OpNd>
  : T_S2op_2_ii <mnemonic, MajOp, MinOp, 0, 0,
    [(set (i32 IntRegs:$dst), (OpNd (i32 IntRegs:$src),
                                    (u5ImmPred:$u5)))]>;

// Arithmetic/logical shift right/left by immediate
let Itinerary = S_2op_tc_1_SLOT23, isCodeGenOnly = 0 in {
  def S2_asr_i_r : T_S2op_shift <"asr", 0b000, 0b000, sra>;
  def S2_lsr_i_r : T_S2op_shift <"lsr", 0b000, 0b001, srl>;
  def S2_asl_i_r : T_S2op_shift <"asl", 0b000, 0b010, shl>;
}

// Shift left by immediate with saturation
let Defs = [USR_OVF], isCodeGenOnly = 0 in
def S2_asl_i_r_sat : T_S2op_2_ii <"asl", 0b010, 0b010, 1>;

// Shift right with round
let isCodeGenOnly = 0 in
def S2_asr_i_r_rnd : T_S2op_2_ii <"asr", 0b010, 0b000, 0, 1>;

def: Pat<(i32 (sra (i32 (add (i32 (sra I32:$src1, u5ImmPred:$src2)),
                             (i32 1))),
                   (i32 1))),
         (S2_asr_i_r_rnd IntRegs:$src1, u5ImmPred:$src2)>;

class T_S2op_3<string opc, bits<2>MajOp, bits<3>minOp, bits<1> sat = 0>
  : SInst<(outs DoubleRegs:$Rdd), (ins DoubleRegs:$Rss),
           "$Rdd = "#opc#"($Rss)"#!if(!eq(sat, 1),":sat","")> {
  bits<5> Rss;
  bits<5> Rdd;
  let IClass = 0b1000;
  let Inst{27-24} = 0;
  let Inst{23-22} = MajOp;
  let Inst{20-16} = Rss;
  let Inst{7-5} = minOp;
  let Inst{4-0} = Rdd;
}

let isCodeGenOnly = 0 in {
def A2_absp : T_S2op_3 <"abs", 0b10, 0b110>;
def A2_negp : T_S2op_3 <"neg", 0b10, 0b101>;
def A2_notp : T_S2op_3 <"not", 0b10, 0b100>;
}

// Innterleave/deinterleave
let isCodeGenOnly = 0 in {
def S2_interleave   : T_S2op_3 <"interleave",   0b11, 0b101>;
def S2_deinterleave : T_S2op_3 <"deinterleave", 0b11, 0b100>;
}

//===----------------------------------------------------------------------===//
// STYPE/BIT +
//===----------------------------------------------------------------------===//
// Bit count

let hasSideEffects = 0, hasNewValue = 1 in
class T_COUNT_LEADING<string MnOp, bits<3> MajOp, bits<3> MinOp, bit Is32,
                dag Out, dag Inp>
    : SInst<Out, Inp, "$Rd = "#MnOp#"($Rs)", [], "", S_2op_tc_1_SLOT23> {
  bits<5> Rs;
  bits<5> Rd;
  let IClass = 0b1000;
  let Inst{27} = 0b1;
  let Inst{26} = Is32;
  let Inst{25-24} = 0b00;
  let Inst{23-21} = MajOp;
  let Inst{20-16} = Rs;
  let Inst{7-5} = MinOp;
  let Inst{4-0} = Rd;
}

class T_COUNT_LEADING_32<string MnOp, bits<3> MajOp, bits<3> MinOp>
    : T_COUNT_LEADING<MnOp, MajOp, MinOp, 0b1,
                      (outs IntRegs:$Rd), (ins IntRegs:$Rs)>;

class T_COUNT_LEADING_64<string MnOp, bits<3> MajOp, bits<3> MinOp>
    : T_COUNT_LEADING<MnOp, MajOp, MinOp, 0b0,
                      (outs IntRegs:$Rd), (ins DoubleRegs:$Rs)>;

let isCodeGenOnly = 0 in {
def S2_cl0     : T_COUNT_LEADING_32<"cl0",     0b000, 0b101>;
def S2_cl1     : T_COUNT_LEADING_32<"cl1",     0b000, 0b110>;
def S2_ct0     : T_COUNT_LEADING_32<"ct0",     0b010, 0b100>;
def S2_ct1     : T_COUNT_LEADING_32<"ct1",     0b010, 0b101>;
def S2_cl0p    : T_COUNT_LEADING_64<"cl0",     0b010, 0b010>;
def S2_cl1p    : T_COUNT_LEADING_64<"cl1",     0b010, 0b100>;
def S2_clb     : T_COUNT_LEADING_32<"clb",     0b000, 0b100>;
def S2_clbp    : T_COUNT_LEADING_64<"clb",     0b010, 0b000>;
def S2_clbnorm : T_COUNT_LEADING_32<"normamt", 0b000, 0b111>;
}

def: Pat<(i32 (ctlz I32:$Rs)),                (S2_cl0 I32:$Rs)>;
def: Pat<(i32 (ctlz (not I32:$Rs))),          (S2_cl1 I32:$Rs)>;
def: Pat<(i32 (cttz I32:$Rs)),                (S2_ct0 I32:$Rs)>;
def: Pat<(i32 (cttz (not I32:$Rs))),          (S2_ct1 I32:$Rs)>;
def: Pat<(i32 (trunc (ctlz I64:$Rss))),       (S2_cl0p I64:$Rss)>;
def: Pat<(i32 (trunc (ctlz (not I64:$Rss)))), (S2_cl1p I64:$Rss)>;

// Bit set/clear/toggle

let hasSideEffects = 0, hasNewValue = 1 in
class T_SCT_BIT_IMM<string MnOp, bits<3> MinOp>
    : SInst<(outs IntRegs:$Rd), (ins IntRegs:$Rs, u5Imm:$u5),
            "$Rd = "#MnOp#"($Rs, #$u5)", [], "", S_2op_tc_1_SLOT23> {
  bits<5> Rd;
  bits<5> Rs;
  bits<5> u5;
  let IClass = 0b1000;
  let Inst{27-21} = 0b1100110;
  let Inst{20-16} = Rs;
  let Inst{13} = 0b0;
  let Inst{12-8} = u5;
  let Inst{7-5} = MinOp;
  let Inst{4-0} = Rd;
}

let hasSideEffects = 0, hasNewValue = 1 in
class T_SCT_BIT_REG<string MnOp, bits<2> MinOp>
    : SInst<(outs IntRegs:$Rd), (ins IntRegs:$Rs, IntRegs:$Rt),
            "$Rd = "#MnOp#"($Rs, $Rt)", [], "", S_3op_tc_1_SLOT23> {
  bits<5> Rd;
  bits<5> Rs;
  bits<5> Rt;
  let IClass = 0b1100;
  let Inst{27-22} = 0b011010;
  let Inst{20-16} = Rs;
  let Inst{12-8} = Rt;
  let Inst{7-6} = MinOp;
  let Inst{4-0} = Rd;
}

let isCodeGenOnly = 0 in {
def S2_clrbit_i    : T_SCT_BIT_IMM<"clrbit",    0b001>;
def S2_setbit_i    : T_SCT_BIT_IMM<"setbit",    0b000>;
def S2_togglebit_i : T_SCT_BIT_IMM<"togglebit", 0b010>;
def S2_clrbit_r    : T_SCT_BIT_REG<"clrbit",    0b01>;
def S2_setbit_r    : T_SCT_BIT_REG<"setbit",    0b00>;
def S2_togglebit_r : T_SCT_BIT_REG<"togglebit", 0b10>;
}

def: Pat<(i32 (and (i32 IntRegs:$Rs), (not (shl 1, u5ImmPred:$u5)))),
         (S2_clrbit_i IntRegs:$Rs, u5ImmPred:$u5)>;
def: Pat<(i32 (or (i32 IntRegs:$Rs), (shl 1, u5ImmPred:$u5))),
         (S2_setbit_i IntRegs:$Rs, u5ImmPred:$u5)>;
def: Pat<(i32 (xor (i32 IntRegs:$Rs), (shl 1, u5ImmPred:$u5))),
         (S2_togglebit_i IntRegs:$Rs, u5ImmPred:$u5)>;
def: Pat<(i32 (and (i32 IntRegs:$Rs), (not (shl 1, (i32 IntRegs:$Rt))))),
         (S2_clrbit_r IntRegs:$Rs, IntRegs:$Rt)>;
def: Pat<(i32 (or (i32 IntRegs:$Rs), (shl 1, (i32 IntRegs:$Rt)))),
         (S2_setbit_r IntRegs:$Rs, IntRegs:$Rt)>;
def: Pat<(i32 (xor (i32 IntRegs:$Rs), (shl 1, (i32 IntRegs:$Rt)))),
         (S2_togglebit_r IntRegs:$Rs, IntRegs:$Rt)>;

// Bit test

let hasSideEffects = 0 in
class T_TEST_BIT_IMM<string MnOp, bits<3> MajOp>
    : SInst<(outs PredRegs:$Pd), (ins IntRegs:$Rs, u5Imm:$u5),
            "$Pd = "#MnOp#"($Rs, #$u5)",
            [], "", S_2op_tc_2early_SLOT23> {
  bits<2> Pd;
  bits<5> Rs;
  bits<5> u5;
  let IClass = 0b1000;
  let Inst{27-24} = 0b0101;
  let Inst{23-21} = MajOp;
  let Inst{20-16} = Rs;
  let Inst{13} = 0;
  let Inst{12-8} = u5;
  let Inst{1-0} = Pd;
}

let hasSideEffects = 0 in
class T_TEST_BIT_REG<string MnOp, bit IsNeg>
    : SInst<(outs PredRegs:$Pd), (ins IntRegs:$Rs, IntRegs:$Rt),
            "$Pd = "#MnOp#"($Rs, $Rt)",
            [], "", S_3op_tc_2early_SLOT23> {
  bits<2> Pd;
  bits<5> Rs;
  bits<5> Rt;
  let IClass = 0b1100;
  let Inst{27-22} = 0b011100;
  let Inst{21} = IsNeg;
  let Inst{20-16} = Rs;
  let Inst{12-8} = Rt;
  let Inst{1-0} = Pd;
}

let isCodeGenOnly = 0 in {
def S2_tstbit_i : T_TEST_BIT_IMM<"tstbit", 0b000>;
def S2_tstbit_r : T_TEST_BIT_REG<"tstbit", 0>;
}

let AddedComplexity = 20 in { // Complexity greater than cmp reg-imm.
  def: Pat<(i1 (setne (and (shl 1, u5ImmPred:$u5), (i32 IntRegs:$Rs)), 0)),
           (S2_tstbit_i IntRegs:$Rs, u5ImmPred:$u5)>;
  def: Pat<(i1 (setne (and (shl 1, (i32 IntRegs:$Rt)), (i32 IntRegs:$Rs)), 0)),
           (S2_tstbit_r IntRegs:$Rs, IntRegs:$Rt)>;
  def: Pat<(i1 (trunc (i32 IntRegs:$Rs))),
           (S2_tstbit_i IntRegs:$Rs, 0)>;
  def: Pat<(i1 (trunc (i64 DoubleRegs:$Rs))),
           (S2_tstbit_i (LoReg DoubleRegs:$Rs), 0)>;
}
let hasSideEffects = 0 in
class T_TEST_BITS_IMM<string MnOp, bits<2> MajOp, bit IsNeg>
    : SInst<(outs PredRegs:$Pd), (ins IntRegs:$Rs, u6Imm:$u6),
            "$Pd = "#MnOp#"($Rs, #$u6)",
            [], "", S_2op_tc_2early_SLOT23> {
  bits<2> Pd;
  bits<5> Rs;
  bits<6> u6;
  let IClass = 0b1000;
  let Inst{27-24} = 0b0101;
  let Inst{23-22} = MajOp;
  let Inst{21} = IsNeg;
  let Inst{20-16} = Rs;
  let Inst{13-8} = u6;
  let Inst{1-0} = Pd;
}

let hasSideEffects = 0 in
class T_TEST_BITS_REG<string MnOp, bits<2> MajOp, bit IsNeg>
    : SInst<(outs PredRegs:$Pd), (ins IntRegs:$Rs, IntRegs:$Rt),
            "$Pd = "#MnOp#"($Rs, $Rt)",
            [], "", S_3op_tc_2early_SLOT23> {
  bits<2> Pd;
  bits<5> Rs;
  bits<5> Rt;
  let IClass = 0b1100;
  let Inst{27-24} = 0b0111;
  let Inst{23-22} = MajOp;
  let Inst{21} = IsNeg;
  let Inst{20-16} = Rs;
  let Inst{12-8} = Rt;
  let Inst{1-0} = Pd;
}

let isCodeGenOnly = 0 in {
def C2_bitsclri : T_TEST_BITS_IMM<"bitsclr", 0b10, 0>;
def C2_bitsclr  : T_TEST_BITS_REG<"bitsclr", 0b10, 0>;
def C2_bitsset  : T_TEST_BITS_REG<"bitsset", 0b01, 0>;
}

let AddedComplexity = 20 in { // Complexity greater than compare reg-imm.
  def: Pat<(i1 (seteq (and (i32 IntRegs:$Rs), u6ImmPred:$u6), 0)),
           (C2_bitsclri IntRegs:$Rs, u6ImmPred:$u6)>;
  def: Pat<(i1 (seteq (and (i32 IntRegs:$Rs), (i32 IntRegs:$Rt)), 0)),
           (C2_bitsclr IntRegs:$Rs, IntRegs:$Rt)>;
}

let AddedComplexity = 10 in   // Complexity greater than compare reg-reg.
def: Pat<(i1 (seteq (and (i32 IntRegs:$Rs), (i32 IntRegs:$Rt)), IntRegs:$Rt)),
         (C2_bitsset IntRegs:$Rs, IntRegs:$Rt)>;

//===----------------------------------------------------------------------===//
// STYPE/BIT -
//===----------------------------------------------------------------------===//

//===----------------------------------------------------------------------===//
// STYPE/COMPLEX +
//===----------------------------------------------------------------------===//
//===----------------------------------------------------------------------===//
// STYPE/COMPLEX -
//===----------------------------------------------------------------------===//

//===----------------------------------------------------------------------===//
// XTYPE/PERM +
//===----------------------------------------------------------------------===//

//===----------------------------------------------------------------------===//
// XTYPE/PERM -
//===----------------------------------------------------------------------===//

//===----------------------------------------------------------------------===//
// STYPE/PRED +
//===----------------------------------------------------------------------===//

// Predicate transfer.
let hasSideEffects = 0, hasNewValue = 1, isCodeGenOnly = 0 in
def C2_tfrpr : SInst<(outs IntRegs:$Rd), (ins PredRegs:$Ps),
      "$Rd = $Ps", [], "", S_2op_tc_1_SLOT23> {
  bits<5> Rd;
  bits<2> Ps;

  let IClass = 0b1000;
  let Inst{27-24} = 0b1001;
  let Inst{22} = 0b1;
  let Inst{17-16} = Ps;
  let Inst{4-0} = Rd;
}

// Transfer general register to predicate.
let hasSideEffects = 0, isCodeGenOnly = 0 in
def C2_tfrrp: SInst<(outs PredRegs:$Pd), (ins IntRegs:$Rs),
      "$Pd = $Rs", [], "", S_2op_tc_2early_SLOT23> {
  bits<2> Pd;
  bits<5> Rs;

  let IClass = 0b1000;
  let Inst{27-21} = 0b0101010;
  let Inst{20-16} = Rs;
  let Inst{1-0} = Pd;
}


//===----------------------------------------------------------------------===//
// STYPE/PRED -
//===----------------------------------------------------------------------===//

//===----------------------------------------------------------------------===//
// STYPE/SHIFT +
//===----------------------------------------------------------------------===//
class S_2OpInstImm<string Mnemonic, bits<3>MajOp, bits<3>MinOp,
                   Operand Imm, list<dag> pattern = [], bit isRnd = 0>
  : SInst<(outs DoubleRegs:$dst), (ins DoubleRegs:$src1, Imm:$src2),
           "$dst = "#Mnemonic#"($src1, #$src2)"#!if(isRnd, ":rnd", ""),
           pattern> {
  bits<5> src1;
  bits<5> dst;
  let IClass = 0b1000;
  let Inst{27-24} = 0;
  let Inst{23-21} = MajOp;
  let Inst{20-16} = src1;
  let Inst{7-5} = MinOp;
  let Inst{4-0} = dst;
}

class S_2OpInstImmI6<string Mnemonic, SDNode OpNode, bits<3>MinOp>
  : S_2OpInstImm<Mnemonic, 0b000, MinOp, u6Imm,
  [(set (i64 DoubleRegs:$dst), (OpNode (i64 DoubleRegs:$src1),
                                        u6ImmPred:$src2))]> {
  bits<6> src2;
  let Inst{13-8} = src2;
}

// Shift by immediate.
let isCodeGenOnly = 0 in {
def S2_asr_i_p : S_2OpInstImmI6<"asr", sra, 0b000>;
def S2_asl_i_p : S_2OpInstImmI6<"asl", shl, 0b010>;
def S2_lsr_i_p : S_2OpInstImmI6<"lsr", srl, 0b001>;
}

// Shift left by small amount and add.
let AddedComplexity = 100, hasNewValue = 1, hasSideEffects = 0,
    isCodeGenOnly = 0 in
def S2_addasl_rrri: SInst <(outs IntRegs:$Rd),
                           (ins IntRegs:$Rt, IntRegs:$Rs, u3Imm:$u3),
  "$Rd = addasl($Rt, $Rs, #$u3)" ,
  [(set (i32 IntRegs:$Rd), (add (i32 IntRegs:$Rt),
                                (shl (i32 IntRegs:$Rs), u3ImmPred:$u3)))],
  "", S_3op_tc_2_SLOT23> {
    bits<5> Rd;
    bits<5> Rt;
    bits<5> Rs;
    bits<3> u3;

    let IClass = 0b1100;

    let Inst{27-21} = 0b0100000;
    let Inst{20-16} = Rs;
    let Inst{13}    = 0b0;
    let Inst{12-8}  = Rt;
    let Inst{7-5}   = u3;
    let Inst{4-0}   = Rd;
  }

// Shift by immediate and add.
let AddedComplexity = 100 in
def ADDASL : SInst<(outs IntRegs:$dst), (ins IntRegs:$src1, IntRegs:$src2,
                                             u3Imm:$src3),
             "$dst = addasl($src1, $src2, #$src3)",
             [(set (i32 IntRegs:$dst), (add (i32 IntRegs:$src1),
                                       (shl (i32 IntRegs:$src2),
                                            u3ImmPred:$src3)))]>;

// Shift by register.
def ASL_rr : SInst<(outs IntRegs:$dst), (ins IntRegs:$src1, IntRegs:$src2),
             "$dst = asl($src1, $src2)",
             [(set (i32 IntRegs:$dst), (shl (i32 IntRegs:$src1),
                                            (i32 IntRegs:$src2)))]>;

def ASR_rr : SInst<(outs IntRegs:$dst), (ins IntRegs:$src1, IntRegs:$src2),
             "$dst = asr($src1, $src2)",
             [(set (i32 IntRegs:$dst), (sra (i32 IntRegs:$src1),
                                            (i32 IntRegs:$src2)))]>;

def LSL_rr : SInst<(outs IntRegs:$dst), (ins IntRegs:$src1, IntRegs:$src2),
             "$dst = lsl($src1, $src2)",
             [(set (i32 IntRegs:$dst), (shl (i32 IntRegs:$src1),
                                            (i32 IntRegs:$src2)))]>;

def LSR_rr : SInst<(outs IntRegs:$dst), (ins IntRegs:$src1, IntRegs:$src2),
             "$dst = lsr($src1, $src2)",
             [(set (i32 IntRegs:$dst), (srl (i32 IntRegs:$src1),
                                            (i32 IntRegs:$src2)))]>;

def ASLd : SInst<(outs DoubleRegs:$dst), (ins DoubleRegs:$src1, IntRegs:$src2),
           "$dst = asl($src1, $src2)",
           [(set (i64 DoubleRegs:$dst), (shl (i64 DoubleRegs:$src1),
                                             (i32 IntRegs:$src2)))]>;

def LSLd : SInst<(outs DoubleRegs:$dst), (ins DoubleRegs:$src1, IntRegs:$src2),
           "$dst = lsl($src1, $src2)",
           [(set (i64 DoubleRegs:$dst), (shl (i64 DoubleRegs:$src1),
                                             (i32 IntRegs:$src2)))]>;

def ASRd_rr : SInst<(outs DoubleRegs:$dst), (ins DoubleRegs:$src1,
                                                 IntRegs:$src2),
              "$dst = asr($src1, $src2)",
              [(set (i64 DoubleRegs:$dst), (sra (i64 DoubleRegs:$src1),
                                                (i32 IntRegs:$src2)))]>;

def LSRd_rr : SInst<(outs DoubleRegs:$dst), (ins DoubleRegs:$src1,
                                                 IntRegs:$src2),
              "$dst = lsr($src1, $src2)",
              [(set (i64 DoubleRegs:$dst), (srl (i64 DoubleRegs:$src1),
                                                (i32 IntRegs:$src2)))]>;

//===----------------------------------------------------------------------===//
// STYPE/SHIFT -
//===----------------------------------------------------------------------===//

//===----------------------------------------------------------------------===//
// STYPE/VH +
//===----------------------------------------------------------------------===//
//===----------------------------------------------------------------------===//
// STYPE/VH -
//===----------------------------------------------------------------------===//

//===----------------------------------------------------------------------===//
// STYPE/VW +
//===----------------------------------------------------------------------===//
//===----------------------------------------------------------------------===//
// STYPE/VW -
//===----------------------------------------------------------------------===//

//===----------------------------------------------------------------------===//
// SYSTEM/SUPER +
//===----------------------------------------------------------------------===//

//===----------------------------------------------------------------------===//
// SYSTEM/USER +
//===----------------------------------------------------------------------===//
def SDHexagonBARRIER: SDTypeProfile<0, 0, []>;
def HexagonBARRIER: SDNode<"HexagonISD::BARRIER", SDHexagonBARRIER,
                           [SDNPHasChain]>;

let hasSideEffects = 1, isSolo = 1 in
def BARRIER : SYSInst<(outs), (ins),
                     "barrier",
                     [(HexagonBARRIER)]>;

//===----------------------------------------------------------------------===//
// SYSTEM/SUPER -
//===----------------------------------------------------------------------===//

// TFRI64 - assembly mapped.
let isReMaterializable = 1 in
def TFRI64 : ALU64_rr<(outs DoubleRegs:$dst), (ins s8Imm64:$src1),
             "$dst = #$src1",
             [(set (i64 DoubleRegs:$dst), s8Imm64Pred:$src1)]>;

let AddedComplexity = 100, isPredicated = 1 in
def TFR_condset_ri : ALU32_rr<(outs IntRegs:$dst),
            (ins PredRegs:$src1, IntRegs:$src2, s12Imm:$src3),
            "Error; should not emit",
            [(set (i32 IntRegs:$dst),
             (i32 (select (i1 PredRegs:$src1), (i32 IntRegs:$src2),
                          s12ImmPred:$src3)))]>;

let AddedComplexity = 100, isPredicated = 1 in
def TFR_condset_ir : ALU32_rr<(outs IntRegs:$dst),
            (ins PredRegs:$src1, s12Imm:$src2, IntRegs:$src3),
            "Error; should not emit",
            [(set (i32 IntRegs:$dst),
             (i32 (select (i1 PredRegs:$src1), s12ImmPred:$src2,
                          (i32 IntRegs:$src3))))]>;

let AddedComplexity = 100, isPredicated = 1 in
def TFR_condset_ii : ALU32_rr<(outs IntRegs:$dst),
                              (ins PredRegs:$src1, s12Imm:$src2, s12Imm:$src3),
                     "Error; should not emit",
                     [(set (i32 IntRegs:$dst),
                           (i32 (select (i1 PredRegs:$src1), s12ImmPred:$src2,
                                        s12ImmPred:$src3)))]>;

// Generate frameindex addresses.
let isReMaterializable = 1 in
def TFR_FI : ALU32_ri<(outs IntRegs:$dst), (ins FrameIndex:$src1),
             "$dst = add($src1)",
             [(set (i32 IntRegs:$dst), ADDRri:$src1)]>;

//
// CR - Type.
//
let hasSideEffects = 0, Defs = [SA0, LC0] in {
def LOOP0_i : CRInst<(outs), (ins brtarget:$offset, u10Imm:$src2),
                      "loop0($offset, #$src2)",
                      []>;
}

let hasSideEffects = 0, Defs = [SA0, LC0] in {
def LOOP0_r : CRInst<(outs), (ins brtarget:$offset, IntRegs:$src2),
                      "loop0($offset, $src2)",
                      []>;
}

let isBranch = 1, isTerminator = 1, hasSideEffects = 0,
    Defs = [PC, LC0], Uses = [SA0, LC0] in {
def ENDLOOP0 : Endloop<(outs), (ins brtarget:$offset),
                       ":endloop0",
                       []>;
}

// Support for generating global address.
// Taken from X86InstrInfo.td.
def SDTHexagonCONST32 : SDTypeProfile<1, 1, [
                                            SDTCisVT<0, i32>,
                                            SDTCisVT<1, i32>,
                                            SDTCisPtrTy<0>]>;
def HexagonCONST32 : SDNode<"HexagonISD::CONST32",     SDTHexagonCONST32>;
def HexagonCONST32_GP : SDNode<"HexagonISD::CONST32_GP",     SDTHexagonCONST32>;

// HI/LO Instructions
let isReMaterializable = 1, isMoveImm = 1, hasSideEffects = 0 in
def LO : ALU32_ri<(outs IntRegs:$dst), (ins globaladdress:$global),
                  "$dst.l = #LO($global)",
                  []>;

let isReMaterializable = 1, isMoveImm = 1, hasSideEffects = 0 in
def HI : ALU32_ri<(outs IntRegs:$dst), (ins globaladdress:$global),
                  "$dst.h = #HI($global)",
                  []>;

let isReMaterializable = 1, isMoveImm = 1, hasSideEffects = 0 in
def LOi : ALU32_ri<(outs IntRegs:$dst), (ins i32imm:$imm_value),
                  "$dst.l = #LO($imm_value)",
                  []>;


let isReMaterializable = 1, isMoveImm = 1, hasSideEffects = 0 in
def HIi : ALU32_ri<(outs IntRegs:$dst), (ins i32imm:$imm_value),
                  "$dst.h = #HI($imm_value)",
                  []>;

let isReMaterializable = 1, isMoveImm = 1, hasSideEffects = 0 in
def LO_jt : ALU32_ri<(outs IntRegs:$dst), (ins jumptablebase:$jt),
                  "$dst.l = #LO($jt)",
                  []>;

let isReMaterializable = 1, isMoveImm = 1, hasSideEffects = 0 in
def HI_jt : ALU32_ri<(outs IntRegs:$dst), (ins jumptablebase:$jt),
                  "$dst.h = #HI($jt)",
                  []>;


let isReMaterializable = 1, isMoveImm = 1, hasSideEffects = 0 in
def LO_label : ALU32_ri<(outs IntRegs:$dst), (ins bblabel:$label),
                  "$dst.l = #LO($label)",
                  []>;

let isReMaterializable = 1, isMoveImm = 1 , hasSideEffects = 0 in
def HI_label : ALU32_ri<(outs IntRegs:$dst), (ins bblabel:$label),
                  "$dst.h = #HI($label)",
                  []>;

// This pattern is incorrect. When we add small data, we should change
// this pattern to use memw(#foo).
// This is for sdata.
let isMoveImm = 1 in
def CONST32 : LDInst<(outs IntRegs:$dst), (ins globaladdress:$global),
              "$dst = CONST32(#$global)",
              [(set (i32 IntRegs:$dst),
                    (load (HexagonCONST32 tglobaltlsaddr:$global)))]>;

// This is for non-sdata.
let isReMaterializable = 1, isMoveImm = 1 in
def CONST32_set : LDInst2<(outs IntRegs:$dst), (ins globaladdress:$global),
                  "$dst = CONST32(#$global)",
                  [(set (i32 IntRegs:$dst),
                        (HexagonCONST32 tglobaladdr:$global))]>;

let isReMaterializable = 1, isMoveImm = 1 in
def CONST32_set_jt : LDInst2<(outs IntRegs:$dst), (ins jumptablebase:$jt),
                     "$dst = CONST32(#$jt)",
                     [(set (i32 IntRegs:$dst),
                           (HexagonCONST32 tjumptable:$jt))]>;

let isReMaterializable = 1, isMoveImm = 1 in
def CONST32GP_set : LDInst2<(outs IntRegs:$dst), (ins globaladdress:$global),
                    "$dst = CONST32(#$global)",
                    [(set (i32 IntRegs:$dst),
                          (HexagonCONST32_GP tglobaladdr:$global))]>;

let isReMaterializable = 1, isMoveImm = 1 in
def CONST32_Int_Real : LDInst2<(outs IntRegs:$dst), (ins i32imm:$global),
                       "$dst = CONST32(#$global)",
                       [(set (i32 IntRegs:$dst), imm:$global) ]>;

// Map BlockAddress lowering to CONST32_Int_Real
def : Pat<(HexagonCONST32_GP tblockaddress:$addr),
          (CONST32_Int_Real tblockaddress:$addr)>;

let isReMaterializable = 1, isMoveImm = 1 in
def CONST32_Label : LDInst2<(outs IntRegs:$dst), (ins bblabel:$label),
                    "$dst = CONST32($label)",
                    [(set (i32 IntRegs:$dst), (HexagonCONST32 bbl:$label))]>;

let isReMaterializable = 1, isMoveImm = 1 in
def CONST64_Int_Real : LDInst2<(outs DoubleRegs:$dst), (ins i64imm:$global),
                       "$dst = CONST64(#$global)",
                       [(set (i64 DoubleRegs:$dst), imm:$global) ]>;

def TFR_PdFalse : SInst<(outs PredRegs:$dst), (ins),
                  "$dst = xor($dst, $dst)",
                  [(set (i1 PredRegs:$dst), 0)]>;

def MPY_trsext : MInst<(outs IntRegs:$dst), (ins IntRegs:$src1, IntRegs:$src2),
       "$dst = mpy($src1, $src2)",
       [(set (i32 IntRegs:$dst),
             (trunc (i64 (srl (i64 (mul (i64 (sext (i32 IntRegs:$src1))),
                                        (i64 (sext (i32 IntRegs:$src2))))),
                              (i32 32)))))]>;

// Pseudo instructions.
def SDT_SPCallSeqStart : SDCallSeqStart<[ SDTCisVT<0, i32> ]>;

def SDT_SPCallSeqEnd : SDCallSeqEnd<[ SDTCisVT<0, i32>,
                                        SDTCisVT<1, i32> ]>;

def callseq_end : SDNode<"ISD::CALLSEQ_END",   SDT_SPCallSeqEnd,
                  [SDNPHasChain, SDNPOptInGlue, SDNPOutGlue]>;

def callseq_start : SDNode<"ISD::CALLSEQ_START", SDT_SPCallSeqStart,
                    [SDNPHasChain, SDNPOutGlue]>;

def SDT_SPCall : SDTypeProfile<0, 1, [SDTCisVT<0, i32>]>;

def call : SDNode<"HexagonISD::CALL", SDT_SPCall,
           [SDNPHasChain, SDNPOptInGlue, SDNPOutGlue, SDNPVariadic]>;

// For tailcalls a HexagonTCRet SDNode has 3 SDNode Properties - a chain,
// Optional Flag and Variable Arguments.
// Its 1 Operand has pointer type.
def HexagonTCRet    : SDNode<"HexagonISD::TC_RETURN", SDT_SPCall,
                     [SDNPHasChain,  SDNPOptInGlue, SDNPVariadic]>;

let Defs = [R29, R30], Uses = [R31, R30, R29] in {
 def ADJCALLSTACKDOWN : Pseudo<(outs), (ins i32imm:$amt),
                        "Should never be emitted",
                        [(callseq_start timm:$amt)]>;
}

let Defs = [R29, R30, R31], Uses = [R29] in {
 def ADJCALLSTACKUP : Pseudo<(outs), (ins i32imm:$amt1, i32imm:$amt2),
                      "Should never be emitted",
                      [(callseq_end timm:$amt1, timm:$amt2)]>;
}
// Call subroutine.
let isCall = 1, hasSideEffects = 0,
  Defs = [D0, D1, D2, D3, D4, D5, D6, D7, D8, D9, D10,
          R22, R23, R28, R31, P0, P1, P2, P3, LC0, LC1, SA0, SA1] in {
  def CALL : JInst<(outs), (ins calltarget:$dst),
             "call $dst", []>;
}

// Call subroutine indirectly.
let Defs = VolatileV3.Regs, isCodeGenOnly = 0 in
def J2_callr : JUMPR_MISC_CALLR<0, 1>;

// Indirect tail-call.
let isCodeGenOnly = 1, isCall = 1, isReturn = 1  in
def TCRETURNR : T_JMPr;

// Direct tail-calls.
let isCall = 1, isReturn = 1, isBarrier = 1, isPredicable = 0,
isTerminator = 1, isCodeGenOnly = 1 in {
  def TCRETURNtg   : JInst<(outs), (ins calltarget:$dst), "jump $dst",
      [], "", J_tc_2early_SLOT23>;
  def TCRETURNtext : JInst<(outs), (ins calltarget:$dst), "jump $dst",
      [], "", J_tc_2early_SLOT23>;
}

// Map call instruction.
def : Pat<(call (i32 IntRegs:$dst)),
      (J2_callr (i32 IntRegs:$dst))>, Requires<[HasV2TOnly]>;
def : Pat<(call tglobaladdr:$dst),
      (CALL tglobaladdr:$dst)>, Requires<[HasV2TOnly]>;
def : Pat<(call texternalsym:$dst),
      (CALL texternalsym:$dst)>, Requires<[HasV2TOnly]>;
//Tail calls.
def : Pat<(HexagonTCRet tglobaladdr:$dst),
      (TCRETURNtg tglobaladdr:$dst)>;
def : Pat<(HexagonTCRet texternalsym:$dst),
      (TCRETURNtext texternalsym:$dst)>;
def : Pat<(HexagonTCRet (i32 IntRegs:$dst)),
      (TCRETURNR (i32 IntRegs:$dst))>;

// Atomic load and store support
// 8 bit atomic load
def : Pat<(atomic_load_8 ADDRriS11_0:$src1),
          (i32 (LDriub ADDRriS11_0:$src1))>;

def : Pat<(atomic_load_8 (add (i32 IntRegs:$src1), s11_0ImmPred:$offset)),
          (i32 (LDriub_indexed (i32 IntRegs:$src1), s11_0ImmPred:$offset))>;

// 16 bit atomic load
def : Pat<(atomic_load_16 ADDRriS11_1:$src1),
          (i32 (LDriuh ADDRriS11_1:$src1))>;

def : Pat<(atomic_load_16 (add (i32 IntRegs:$src1), s11_1ImmPred:$offset)),
          (i32 (LDriuh_indexed (i32 IntRegs:$src1), s11_1ImmPred:$offset))>;

def : Pat<(atomic_load_32 ADDRriS11_2:$src1),
          (i32 (LDriw ADDRriS11_2:$src1))>;

def : Pat<(atomic_load_32 (add (i32 IntRegs:$src1), s11_2ImmPred:$offset)),
          (i32 (LDriw_indexed (i32 IntRegs:$src1), s11_2ImmPred:$offset))>;

// 64 bit atomic load
def : Pat<(atomic_load_64 ADDRriS11_3:$src1),
          (i64 (LDrid ADDRriS11_3:$src1))>;

def : Pat<(atomic_load_64 (add (i32 IntRegs:$src1), s11_3ImmPred:$offset)),
          (i64 (LDrid_indexed (i32 IntRegs:$src1), s11_3ImmPred:$offset))>;


def : Pat<(atomic_store_8 ADDRriS11_0:$src2, (i32 IntRegs:$src1)),
          (STrib ADDRriS11_0:$src2, (i32 IntRegs:$src1))>;

def : Pat<(atomic_store_8 (add (i32 IntRegs:$src2), s11_0ImmPred:$offset),
                          (i32 IntRegs:$src1)),
          (STrib_indexed (i32 IntRegs:$src2), s11_0ImmPred:$offset,
                         (i32 IntRegs:$src1))>;


def : Pat<(atomic_store_16 ADDRriS11_1:$src2, (i32 IntRegs:$src1)),
          (STrih ADDRriS11_1:$src2, (i32 IntRegs:$src1))>;

def : Pat<(atomic_store_16 (i32 IntRegs:$src1),
                          (add (i32 IntRegs:$src2), s11_1ImmPred:$offset)),
          (STrih_indexed (i32 IntRegs:$src2), s11_1ImmPred:$offset,
                         (i32 IntRegs:$src1))>;

def : Pat<(atomic_store_32 ADDRriS11_2:$src2, (i32 IntRegs:$src1)),
          (STriw ADDRriS11_2:$src2, (i32 IntRegs:$src1))>;

def : Pat<(atomic_store_32 (add (i32 IntRegs:$src2), s11_2ImmPred:$offset),
                           (i32 IntRegs:$src1)),
          (STriw_indexed (i32 IntRegs:$src2), s11_2ImmPred:$offset,
                         (i32 IntRegs:$src1))>;




def : Pat<(atomic_store_64 ADDRriS11_3:$src2, (i64 DoubleRegs:$src1)),
          (STrid ADDRriS11_3:$src2, (i64 DoubleRegs:$src1))>;

def : Pat<(atomic_store_64 (add (i32 IntRegs:$src2), s11_3ImmPred:$offset),
                           (i64 DoubleRegs:$src1)),
          (STrid_indexed (i32 IntRegs:$src2), s11_3ImmPred:$offset,
                         (i64 DoubleRegs:$src1))>;

// Map from r0 = and(r1, 65535) to r0 = zxth(r1)
def : Pat <(and (i32 IntRegs:$src1), 65535),
      (A2_zxth (i32 IntRegs:$src1))>;

// Map from r0 = and(r1, 255) to r0 = zxtb(r1).
def : Pat <(and (i32 IntRegs:$src1), 255),
      (A2_zxtb (i32 IntRegs:$src1))>;

// Map Add(p1, true) to p1 = not(p1).
//     Add(p1, false) should never be produced,
//     if it does, it got to be mapped to NOOP.
def : Pat <(add (i1 PredRegs:$src1), -1),
      (C2_not (i1 PredRegs:$src1))>;

// Map from p0 = pnot(p0); r0 = mux(p0, #i, #j) => r0 = mux(p0, #j, #i).
def : Pat <(select (not (i1 PredRegs:$src1)), s8ImmPred:$src2, s8ImmPred:$src3),
      (i32 (TFR_condset_ii (i1 PredRegs:$src1), s8ImmPred:$src3,
                           s8ImmPred:$src2))>;

// Map from p0 = pnot(p0); r0 = select(p0, #i, r1)
// => r0 = TFR_condset_ri(p0, r1, #i)
def : Pat <(select (not (i1 PredRegs:$src1)), s12ImmPred:$src2,
                   (i32 IntRegs:$src3)),
      (i32 (TFR_condset_ri (i1 PredRegs:$src1), (i32 IntRegs:$src3),
                           s12ImmPred:$src2))>;

// Map from p0 = pnot(p0); r0 = mux(p0, r1, #i)
// => r0 = TFR_condset_ir(p0, #i, r1)
def : Pat <(select (not (i1 PredRegs:$src1)), IntRegs:$src2, s12ImmPred:$src3),
      (i32 (TFR_condset_ir (i1 PredRegs:$src1), s12ImmPred:$src3,
                           (i32 IntRegs:$src2)))>;

// Map from p0 = pnot(p0); if (p0) jump => if (!p0) jump.
def : Pat <(brcond (not (i1 PredRegs:$src1)), bb:$offset),
      (J2_jumpf (i1 PredRegs:$src1), bb:$offset)>;

// Map from p2 = pnot(p2); p1 = and(p0, p2) => p1 = and(p0, !p2).
def : Pat <(and (i1 PredRegs:$src1), (not (i1 PredRegs:$src2))),
      (i1 (C2_andn (i1 PredRegs:$src1), (i1 PredRegs:$src2)))>;


let AddedComplexity = 100 in
def : Pat <(i64 (zextloadi1 (HexagonCONST32 tglobaladdr:$global))),
      (i64 (A2_combinew (A2_tfrsi 0),
                       (LDriub_indexed (CONST32_set tglobaladdr:$global), 0)))>,
      Requires<[NoV4T]>;

// Map from i1 loads to 32 bits. This assumes that the i1* is byte aligned.
let AddedComplexity = 10 in
def : Pat <(i32 (zextloadi1 ADDRriS11_0:$addr)),
      (i32 (A2_and (i32 (LDrib ADDRriS11_0:$addr)), (A2_tfrsi 0x1)))>;

// Map from Rdd = sign_extend_inreg(Rss, i32) -> Rdd = A2_sxtw(Rss.lo).
def : Pat <(i64 (sext_inreg (i64 DoubleRegs:$src1), i32)),
      (i64 (A2_sxtw (i32 (EXTRACT_SUBREG (i64 DoubleRegs:$src1), subreg_loreg))))>;

// Map from Rdd = sign_extend_inreg(Rss, i16) -> Rdd = A2_sxtw(SXTH(Rss.lo)).
def : Pat <(i64 (sext_inreg (i64 DoubleRegs:$src1), i16)),
      (i64 (A2_sxtw (i32 (A2_sxth (i32 (EXTRACT_SUBREG (i64 DoubleRegs:$src1),
                                                 subreg_loreg))))))>;

// Map from Rdd = sign_extend_inreg(Rss, i8) -> Rdd = A2_sxtw(SXTB(Rss.lo)).
def : Pat <(i64 (sext_inreg (i64 DoubleRegs:$src1), i8)),
      (i64 (A2_sxtw (i32 (A2_sxtb (i32 (EXTRACT_SUBREG (i64 DoubleRegs:$src1),
                                                 subreg_loreg))))))>;

// We want to prevent emitting pnot's as much as possible.
// Map brcond with an unsupported setcc to a J2_jumpf.
def : Pat <(brcond (i1 (setne (i32 IntRegs:$src1), (i32 IntRegs:$src2))),
                        bb:$offset),
      (J2_jumpf (C2_cmpeq (i32 IntRegs:$src1), (i32 IntRegs:$src2)),
                bb:$offset)>;

def : Pat <(brcond (i1 (setne (i32 IntRegs:$src1), s10ImmPred:$src2)),
                        bb:$offset),
      (J2_jumpf (C2_cmpeqi (i32 IntRegs:$src1), s10ImmPred:$src2), bb:$offset)>;

def : Pat <(brcond (i1 (setne (i1 PredRegs:$src1), (i1 -1))), bb:$offset),
      (J2_jumpf (i1 PredRegs:$src1), bb:$offset)>;

def : Pat <(brcond (i1 (setne (i1 PredRegs:$src1), (i1 0))), bb:$offset),
      (J2_jumpt (i1 PredRegs:$src1), bb:$offset)>;

// cmp.lt(Rs, Imm) -> !cmp.ge(Rs, Imm) -> !cmp.gt(Rs, Imm-1)
def : Pat <(brcond (i1 (setlt (i32 IntRegs:$src1), s8ImmPred:$src2)),
                        bb:$offset),
      (J2_jumpf (C2_cmpgti (i32 IntRegs:$src1),
                (DEC_CONST_SIGNED s8ImmPred:$src2)), bb:$offset)>;

// cmp.lt(r0, r1) -> cmp.gt(r1, r0)
def : Pat <(brcond (i1 (setlt (i32 IntRegs:$src1), (i32 IntRegs:$src2))),
                        bb:$offset),
      (J2_jumpt (C2_cmpgt (i32 IntRegs:$src2), (i32 IntRegs:$src1)), bb:$offset)>;

def : Pat <(brcond (i1 (setuge (i64 DoubleRegs:$src1), (i64 DoubleRegs:$src2))),
                   bb:$offset),
      (J2_jumpf (C2_cmpgtup (i64 DoubleRegs:$src2), (i64 DoubleRegs:$src1)),
                   bb:$offset)>;

def : Pat <(brcond (i1 (setule (i32 IntRegs:$src1), (i32 IntRegs:$src2))),
                        bb:$offset),
      (J2_jumpf (C2_cmpgtu (i32 IntRegs:$src1), (i32 IntRegs:$src2)),
                bb:$offset)>;

def : Pat <(brcond (i1 (setule (i64 DoubleRegs:$src1), (i64 DoubleRegs:$src2))),
                   bb:$offset),
      (J2_jumpf (C2_cmpgtup (i64 DoubleRegs:$src1), (i64 DoubleRegs:$src2)),
                bb:$offset)>;

// Map from a 64-bit select to an emulated 64-bit mux.
// Hexagon does not support 64-bit MUXes; so emulate with combines.
def : Pat <(select (i1 PredRegs:$src1), (i64 DoubleRegs:$src2),
                   (i64 DoubleRegs:$src3)),
      (i64 (A2_combinew (i32 (C2_mux (i1 PredRegs:$src1),
                                    (i32 (EXTRACT_SUBREG (i64 DoubleRegs:$src2),
                                                         subreg_hireg)),
                                    (i32 (EXTRACT_SUBREG (i64 DoubleRegs:$src3),
                                                         subreg_hireg)))),
                       (i32 (C2_mux (i1 PredRegs:$src1),
                                    (i32 (EXTRACT_SUBREG (i64 DoubleRegs:$src2),
                                                         subreg_loreg)),
                                    (i32 (EXTRACT_SUBREG (i64 DoubleRegs:$src3),
                                                         subreg_loreg))))))>;

// Map from a 1-bit select to logical ops.
// From LegalizeDAG.cpp: (B1 ? B2 : B3) <=> (B1 & B2)|(!B1&B3).
def : Pat <(select (i1 PredRegs:$src1), (i1 PredRegs:$src2),
                   (i1 PredRegs:$src3)),
      (C2_or (C2_and (i1 PredRegs:$src1), (i1 PredRegs:$src2)),
             (C2_and (C2_not (i1 PredRegs:$src1)), (i1 PredRegs:$src3)))>;

// Map Pd = load(addr) -> Rs = load(addr); Pd = Rs.
def : Pat<(i1 (load ADDRriS11_2:$addr)),
      (i1 (C2_tfrrp (i32 (LDrib ADDRriS11_2:$addr))))>;

// Map for truncating from 64 immediates to 32 bit immediates.
def : Pat<(i32 (trunc (i64 DoubleRegs:$src))),
      (i32 (EXTRACT_SUBREG (i64 DoubleRegs:$src), subreg_loreg))>;

// Map for truncating from i64 immediates to i1 bit immediates.
def :  Pat<(i1 (trunc (i64 DoubleRegs:$src))),
       (i1 (C2_tfrrp (i32 (EXTRACT_SUBREG (i64 DoubleRegs:$src),
                                          subreg_loreg))))>;

// Map memb(Rs) = Rdd -> memb(Rs) = Rt.
def : Pat<(truncstorei8 (i64 DoubleRegs:$src), ADDRriS11_0:$addr),
      (STrib ADDRriS11_0:$addr, (i32 (EXTRACT_SUBREG (i64 DoubleRegs:$src),
                                                     subreg_loreg)))>;

// Map memh(Rs) = Rdd -> memh(Rs) = Rt.
def : Pat<(truncstorei16 (i64 DoubleRegs:$src), ADDRriS11_0:$addr),
      (STrih ADDRriS11_0:$addr, (i32 (EXTRACT_SUBREG (i64 DoubleRegs:$src),
                                                     subreg_loreg)))>;
// Map memw(Rs) = Rdd -> memw(Rs) = Rt
def : Pat<(truncstorei32 (i64  DoubleRegs:$src), ADDRriS11_0:$addr),
      (STriw ADDRriS11_0:$addr, (i32 (EXTRACT_SUBREG (i64 DoubleRegs:$src),
                                                     subreg_loreg)))>;

// Map memw(Rs) = Rdd -> memw(Rs) = Rt.
def : Pat<(truncstorei32 (i64 DoubleRegs:$src), ADDRriS11_0:$addr),
      (STriw ADDRriS11_0:$addr, (i32 (EXTRACT_SUBREG (i64 DoubleRegs:$src),
                                                     subreg_loreg)))>;

// Map from i1 = constant<-1>; memw(addr) = i1 -> r0 = 1; memw(addr) = r0.
def : Pat<(store (i1 -1), ADDRriS11_2:$addr),
      (STrib ADDRriS11_2:$addr, (A2_tfrsi 1))>;


// Map from i1 = constant<-1>; store i1 -> r0 = 1; store r0.
def : Pat<(store (i1 -1), ADDRriS11_2:$addr),
      (STrib ADDRriS11_2:$addr, (A2_tfrsi 1))>;

// Map from memb(Rs) = Pd -> Rt = mux(Pd, #0, #1); store Rt.
def : Pat<(store (i1 PredRegs:$src1), ADDRriS11_2:$addr),
      (STrib ADDRriS11_2:$addr, (i32 (C2_muxii (i1 PredRegs:$src1), 1, 0)) )>;

// Map Rdd = anyext(Rs) -> Rdd = A2_sxtw(Rs).
// Hexagon_TODO: We can probably use combine but that will cost 2 instructions.
// Better way to do this?
def : Pat<(i64 (anyext (i32 IntRegs:$src1))),
      (i64 (A2_sxtw (i32 IntRegs:$src1)))>;

// Map cmple -> cmpgt.
// rs <= rt -> !(rs > rt).
def : Pat<(i1 (setle (i32 IntRegs:$src1), s10ExtPred:$src2)),
      (i1 (C2_not (C2_cmpgti (i32 IntRegs:$src1), s10ExtPred:$src2)))>;

// rs <= rt -> !(rs > rt).
def : Pat<(i1 (setle (i32 IntRegs:$src1), (i32 IntRegs:$src2))),
      (i1 (C2_not (C2_cmpgt (i32 IntRegs:$src1), (i32 IntRegs:$src2))))>;

// Rss <= Rtt -> !(Rss > Rtt).
def : Pat<(i1 (setle (i64 DoubleRegs:$src1), (i64 DoubleRegs:$src2))),
      (i1 (C2_not (C2_cmpgtp (i64 DoubleRegs:$src1), (i64 DoubleRegs:$src2))))>;

// Map cmpne -> cmpeq.
// Hexagon_TODO: We should improve on this.
// rs != rt -> !(rs == rt).
def : Pat <(i1 (setne (i32 IntRegs:$src1), s10ExtPred:$src2)),
      (i1 (C2_not(i1 (C2_cmpeqi (i32 IntRegs:$src1), s10ExtPred:$src2))))>;

// Map cmpne(Rs) -> !cmpeqe(Rs).
// rs != rt -> !(rs == rt).
def : Pat <(i1 (setne (i32 IntRegs:$src1), (i32 IntRegs:$src2))),
      (i1 (C2_not (i1 (C2_cmpeq (i32 IntRegs:$src1), (i32 IntRegs:$src2)))))>;

// Convert setne back to xor for hexagon since we compute w/ pred registers.
def : Pat <(i1 (setne (i1 PredRegs:$src1), (i1 PredRegs:$src2))),
      (i1 (C2_xor (i1 PredRegs:$src1), (i1 PredRegs:$src2)))>;

// Map cmpne(Rss) -> !cmpew(Rss).
// rs != rt -> !(rs == rt).
def : Pat <(i1 (setne (i64 DoubleRegs:$src1), (i64 DoubleRegs:$src2))),
      (i1 (C2_not (i1 (C2_cmpeqp (i64 DoubleRegs:$src1),
                                     (i64 DoubleRegs:$src2)))))>;

// Map cmpge(Rs, Rt) -> !(cmpgt(Rs, Rt).
// rs >= rt -> !(rt > rs).
def : Pat <(i1 (setge (i32 IntRegs:$src1), (i32 IntRegs:$src2))),
      (i1 (C2_not (i1 (C2_cmpgt (i32 IntRegs:$src2), (i32 IntRegs:$src1)))))>;

// cmpge(Rs, Imm) -> cmpgt(Rs, Imm-1)
def : Pat <(i1 (setge (i32 IntRegs:$src1), s8ExtPred:$src2)),
      (i1 (C2_cmpgti (i32 IntRegs:$src1), (DEC_CONST_SIGNED s8ExtPred:$src2)))>;

// Map cmpge(Rss, Rtt) -> !cmpgt(Rtt, Rss).
// rss >= rtt -> !(rtt > rss).
def : Pat <(i1 (setge (i64 DoubleRegs:$src1), (i64 DoubleRegs:$src2))),
      (i1 (C2_not (i1 (C2_cmpgtp (i64 DoubleRegs:$src2),
                                (i64 DoubleRegs:$src1)))))>;

// Map cmplt(Rs, Imm) -> !cmpge(Rs, Imm).
// !cmpge(Rs, Imm) -> !cmpgt(Rs, Imm-1).
// rs < rt -> !(rs >= rt).
def : Pat <(i1 (setlt (i32 IntRegs:$src1), s8ExtPred:$src2)),
      (i1 (C2_not (C2_cmpgti (i32 IntRegs:$src1), (DEC_CONST_SIGNED s8ExtPred:$src2))))>;

// Map cmplt(Rs, Rt) -> cmpgt(Rt, Rs).
// rs < rt -> rt > rs.
// We can let assembler map it, or we can do in the compiler itself.
def : Pat <(i1 (setlt (i32 IntRegs:$src1), (i32 IntRegs:$src2))),
      (i1 (C2_cmpgt (i32 IntRegs:$src2), (i32 IntRegs:$src1)))>;

// Map cmplt(Rss, Rtt) -> cmpgt(Rtt, Rss).
// rss < rtt -> (rtt > rss).
def : Pat <(i1 (setlt (i64 DoubleRegs:$src1), (i64 DoubleRegs:$src2))),
      (i1 (C2_cmpgtp (i64 DoubleRegs:$src2), (i64 DoubleRegs:$src1)))>;

// Map from cmpltu(Rs, Rd) -> cmpgtu(Rd, Rs)
// rs < rt -> rt > rs.
// We can let assembler map it, or we can do in the compiler itself.
def : Pat <(i1 (setult (i32 IntRegs:$src1), (i32 IntRegs:$src2))),
      (i1 (C2_cmpgtu (i32 IntRegs:$src2), (i32 IntRegs:$src1)))>;

// Map from cmpltu(Rss, Rdd) -> cmpgtu(Rdd, Rss).
// rs < rt -> rt > rs.
def : Pat <(i1 (setult (i64 DoubleRegs:$src1), (i64 DoubleRegs:$src2))),
      (i1 (C2_cmpgtup (i64 DoubleRegs:$src2), (i64 DoubleRegs:$src1)))>;

// Generate cmpgeu(Rs, #0) -> cmpeq(Rs, Rs)
def : Pat <(i1 (setuge (i32 IntRegs:$src1), 0)),
      (i1 (C2_cmpeq (i32 IntRegs:$src1), (i32 IntRegs:$src1)))>;

// Generate cmpgeu(Rs, #u8) -> cmpgtu(Rs, #u8 -1)
def : Pat <(i1 (setuge (i32 IntRegs:$src1), u8ExtPred:$src2)),
      (i1 (C2_cmpgtui (i32 IntRegs:$src1), (DEC_CONST_UNSIGNED u8ExtPred:$src2)))>;

// Generate cmpgtu(Rs, #u9)
def : Pat <(i1 (setugt (i32 IntRegs:$src1), u9ExtPred:$src2)),
      (i1 (C2_cmpgtui (i32 IntRegs:$src1), u9ExtPred:$src2))>;

// Map from Rs >= Rt -> !(Rt > Rs).
// rs >= rt -> !(rt > rs).
def : Pat <(i1 (setuge (i32 IntRegs:$src1), (i32 IntRegs:$src2))),
      (i1 (C2_not (C2_cmpgtu (i32 IntRegs:$src2), (i32 IntRegs:$src1))))>;

// Map from Rs >= Rt -> !(Rt > Rs).
// rs >= rt -> !(rt > rs).
def : Pat <(i1 (setuge (i64 DoubleRegs:$src1), (i64 DoubleRegs:$src2))),
      (i1 (C2_not (C2_cmpgtup (i64 DoubleRegs:$src2), (i64 DoubleRegs:$src1))))>;

// Map from cmpleu(Rs, Rt) -> !cmpgtu(Rs, Rt).
// Map from (Rs <= Rt) -> !(Rs > Rt).
def : Pat <(i1 (setule (i32 IntRegs:$src1), (i32 IntRegs:$src2))),
      (i1 (C2_not (C2_cmpgtu (i32 IntRegs:$src1), (i32 IntRegs:$src2))))>;

// Map from cmpleu(Rss, Rtt) -> !cmpgtu(Rss, Rtt-1).
// Map from (Rs <= Rt) -> !(Rs > Rt).
def : Pat <(i1 (setule (i64 DoubleRegs:$src1), (i64 DoubleRegs:$src2))),
      (i1 (C2_not (C2_cmpgtup (i64 DoubleRegs:$src1), (i64 DoubleRegs:$src2))))>;

// Sign extends.
// i1 -> i32
def : Pat <(i32 (sext (i1 PredRegs:$src1))),
      (i32 (C2_muxii (i1 PredRegs:$src1), -1, 0))>;

// i1 -> i64
def : Pat <(i64 (sext (i1 PredRegs:$src1))),
      (i64 (A2_combinew (A2_tfrsi -1), (C2_muxii (i1 PredRegs:$src1), -1, 0)))>;

// Convert sign-extended load back to load and sign extend.
// i8 -> i64
def:  Pat <(i64 (sextloadi8 ADDRriS11_0:$src1)),
      (i64 (A2_sxtw (LDrib ADDRriS11_0:$src1)))>;

// Convert any-extended load back to load and sign extend.
// i8 -> i64
def:  Pat <(i64 (extloadi8 ADDRriS11_0:$src1)),
      (i64 (A2_sxtw (LDrib ADDRriS11_0:$src1)))>;

// Convert sign-extended load back to load and sign extend.
// i16 -> i64
def:  Pat <(i64 (sextloadi16 ADDRriS11_1:$src1)),
      (i64 (A2_sxtw (LDrih ADDRriS11_1:$src1)))>;

// Convert sign-extended load back to load and sign extend.
// i32 -> i64
def:  Pat <(i64 (sextloadi32 ADDRriS11_2:$src1)),
      (i64 (A2_sxtw (LDriw ADDRriS11_2:$src1)))>;


// Zero extends.
// i1 -> i32
def : Pat <(i32 (zext (i1 PredRegs:$src1))),
      (i32 (C2_muxii (i1 PredRegs:$src1), 1, 0))>;

// i1 -> i64
def : Pat <(i64 (zext (i1 PredRegs:$src1))),
      (i64 (A2_combinew (A2_tfrsi 0), (C2_muxii (i1 PredRegs:$src1), 1, 0)))>,
      Requires<[NoV4T]>;

// i32 -> i64
def : Pat <(i64 (zext (i32 IntRegs:$src1))),
      (i64 (A2_combinew (A2_tfrsi 0), (i32 IntRegs:$src1)))>,
      Requires<[NoV4T]>;

// i8 -> i64
def:  Pat <(i64 (zextloadi8 ADDRriS11_0:$src1)),
      (i64 (A2_combinew (A2_tfrsi 0), (LDriub ADDRriS11_0:$src1)))>,
      Requires<[NoV4T]>;

let AddedComplexity = 20 in
def:  Pat <(i64 (zextloadi8 (add (i32 IntRegs:$src1),
                                s11_0ExtPred:$offset))),
      (i64 (A2_combinew (A2_tfrsi 0), (LDriub_indexed IntRegs:$src1,
                                  s11_0ExtPred:$offset)))>,
      Requires<[NoV4T]>;

// i1 -> i64
def:  Pat <(i64 (zextloadi1 ADDRriS11_0:$src1)),
      (i64 (A2_combinew (A2_tfrsi 0), (LDriub ADDRriS11_0:$src1)))>,
      Requires<[NoV4T]>;

let AddedComplexity = 20 in
def:  Pat <(i64 (zextloadi1 (add (i32 IntRegs:$src1),
                                s11_0ExtPred:$offset))),
      (i64 (A2_combinew (A2_tfrsi 0), (LDriub_indexed IntRegs:$src1,
                                  s11_0ExtPred:$offset)))>,
      Requires<[NoV4T]>;

// i16 -> i64
def:  Pat <(i64 (zextloadi16 ADDRriS11_1:$src1)),
      (i64 (A2_combinew (A2_tfrsi 0), (LDriuh ADDRriS11_1:$src1)))>,
      Requires<[NoV4T]>;

let AddedComplexity = 20 in
def:  Pat <(i64 (zextloadi16 (add (i32 IntRegs:$src1),
                                  s11_1ExtPred:$offset))),
      (i64 (A2_combinew (A2_tfrsi 0), (LDriuh_indexed IntRegs:$src1,
                                  s11_1ExtPred:$offset)))>,
      Requires<[NoV4T]>;

// i32 -> i64
def:  Pat <(i64 (zextloadi32 ADDRriS11_2:$src1)),
      (i64 (A2_combinew (A2_tfrsi 0), (LDriw ADDRriS11_2:$src1)))>,
      Requires<[NoV4T]>;

let AddedComplexity = 100 in
def:  Pat <(i64 (zextloadi32 (i32 (add IntRegs:$src1, s11_2ExtPred:$offset)))),
      (i64 (A2_combinew (A2_tfrsi 0), (LDriw_indexed IntRegs:$src1,
                                  s11_2ExtPred:$offset)))>,
      Requires<[NoV4T]>;

let AddedComplexity = 10 in
def:  Pat <(i32 (zextloadi1 ADDRriS11_0:$src1)),
      (i32 (LDriw ADDRriS11_0:$src1))>;

// Map from Rs = Pd to Pd = mux(Pd, #1, #0)
def : Pat <(i32 (zext (i1 PredRegs:$src1))),
      (i32 (C2_muxii (i1 PredRegs:$src1), 1, 0))>;

// Map from Rs = Pd to Pd = mux(Pd, #1, #0)
def : Pat <(i32 (anyext (i1 PredRegs:$src1))),
      (i32 (C2_muxii (i1 PredRegs:$src1), 1, 0))>;

// Map from Rss = Pd to Rdd = A2_sxtw (mux(Pd, #1, #0))
def : Pat <(i64 (anyext (i1 PredRegs:$src1))),
      (i64 (A2_sxtw (i32 (C2_muxii (i1 PredRegs:$src1), 1, 0))))>;


let AddedComplexity = 100 in
def: Pat<(i64 (or (i64 (shl (i64 DoubleRegs:$srcHigh),
                           (i32 32))),
               (i64 (zextloadi32 (i32 (add IntRegs:$src2,
                                         s11_2ExtPred:$offset2)))))),
        (i64 (A2_combinew (EXTRACT_SUBREG (i64 DoubleRegs:$srcHigh), subreg_loreg),
                        (LDriw_indexed IntRegs:$src2,
                                       s11_2ExtPred:$offset2)))>;

def: Pat<(i64 (or (i64 (shl (i64 DoubleRegs:$srcHigh),
                           (i32 32))),
               (i64 (zextloadi32 ADDRriS11_2:$srcLow)))),
        (i64 (A2_combinew (EXTRACT_SUBREG (i64 DoubleRegs:$srcHigh), subreg_loreg),
                        (LDriw ADDRriS11_2:$srcLow)))>;

def: Pat<(i64 (or (i64 (shl (i64 DoubleRegs:$srcHigh),
                           (i32 32))),
               (i64 (zext (i32 IntRegs:$srcLow))))),
        (i64 (A2_combinew (EXTRACT_SUBREG (i64 DoubleRegs:$srcHigh), subreg_loreg),
                        IntRegs:$srcLow))>;

let AddedComplexity = 100 in
def: Pat<(i64 (or (i64 (shl (i64 DoubleRegs:$srcHigh),
                           (i32 32))),
               (i64 (zextloadi32 (i32 (add IntRegs:$src2,
                                         s11_2ExtPred:$offset2)))))),
        (i64 (A2_combinew (EXTRACT_SUBREG (i64 DoubleRegs:$srcHigh), subreg_loreg),
                        (LDriw_indexed IntRegs:$src2,
                                       s11_2ExtPred:$offset2)))>;

def: Pat<(i64 (or (i64 (shl (i64 DoubleRegs:$srcHigh),
                           (i32 32))),
               (i64 (zextloadi32 ADDRriS11_2:$srcLow)))),
        (i64 (A2_combinew (EXTRACT_SUBREG (i64 DoubleRegs:$srcHigh), subreg_loreg),
                        (LDriw ADDRriS11_2:$srcLow)))>;

def: Pat<(i64 (or (i64 (shl (i64 DoubleRegs:$srcHigh),
                           (i32 32))),
               (i64 (zext (i32 IntRegs:$srcLow))))),
        (i64 (A2_combinew (EXTRACT_SUBREG (i64 DoubleRegs:$srcHigh), subreg_loreg),
                        IntRegs:$srcLow))>;

// Any extended 64-bit load.
// anyext i32 -> i64
def:  Pat <(i64 (extloadi32 ADDRriS11_2:$src1)),
      (i64 (A2_combinew (A2_tfrsi 0), (LDriw ADDRriS11_2:$src1)))>,
      Requires<[NoV4T]>;

// When there is an offset we should prefer the pattern below over the pattern above.
// The complexity of the above is 13 (gleaned from HexagonGenDAGIsel.inc)
// So this complexity below is comfortably higher to allow for choosing the below.
// If this is not done then we generate addresses such as
// ********************************************
//        r1 = add (r0, #4)
//        r1 = memw(r1 + #0)
//  instead of
//        r1 = memw(r0 + #4)
// ********************************************
let AddedComplexity = 100 in
def:  Pat <(i64 (extloadi32 (i32 (add IntRegs:$src1, s11_2ExtPred:$offset)))),
      (i64 (A2_combinew (A2_tfrsi 0), (LDriw_indexed IntRegs:$src1,
                                  s11_2ExtPred:$offset)))>,
      Requires<[NoV4T]>;

// anyext i16 -> i64.
def:  Pat <(i64 (extloadi16 ADDRriS11_2:$src1)),
      (i64 (A2_combinew (A2_tfrsi 0), (LDrih ADDRriS11_2:$src1)))>,
      Requires<[NoV4T]>;

let AddedComplexity = 20 in
def:  Pat <(i64 (extloadi16 (add (i32 IntRegs:$src1),
                                  s11_1ExtPred:$offset))),
      (i64 (A2_combinew (A2_tfrsi 0), (LDrih_indexed IntRegs:$src1,
                                  s11_1ExtPred:$offset)))>,
      Requires<[NoV4T]>;

// Map from Rdd = zxtw(Rs) -> Rdd = combine(0, Rs).
def : Pat<(i64 (zext (i32 IntRegs:$src1))),
      (i64 (A2_combinew (A2_tfrsi 0), (i32 IntRegs:$src1)))>,
      Requires<[NoV4T]>;

// Multiply 64-bit unsigned and use upper result.
def : Pat <(mulhu (i64 DoubleRegs:$src1), (i64 DoubleRegs:$src2)),
      (i64
       (M2_dpmpyuu_acc_s0
        (i64
         (A2_combinew
          (A2_tfrsi 0),
           (i32
            (EXTRACT_SUBREG
             (i64
              (S2_lsr_i_p
               (i64
                (M2_dpmpyuu_acc_s0
                 (i64
                  (M2_dpmpyuu_acc_s0
                   (i64
                    (A2_combinew (A2_tfrsi 0),
                     (i32
                      (EXTRACT_SUBREG
                       (i64
                        (S2_lsr_i_p
                         (i64
                          (M2_dpmpyuu_s0 
                            (i32 (EXTRACT_SUBREG (i64 DoubleRegs:$src1),
                                                       subreg_loreg)),
                                  (i32 (EXTRACT_SUBREG (i64 DoubleRegs:$src2),
                                                       subreg_loreg)))), 32)),
                       subreg_loreg)))),
                  (i32 (EXTRACT_SUBREG (i64 DoubleRegs:$src1), subreg_hireg)),
                  (i32 (EXTRACT_SUBREG (i64 DoubleRegs:$src2), subreg_loreg)))),
                 (i32 (EXTRACT_SUBREG (i64 DoubleRegs:$src1), subreg_loreg)),
                 (i32 (EXTRACT_SUBREG (i64 DoubleRegs:$src2), subreg_hireg)))),
               32)), subreg_loreg)))),
        (i32 (EXTRACT_SUBREG (i64 DoubleRegs:$src1), subreg_hireg)),
        (i32 (EXTRACT_SUBREG (i64 DoubleRegs:$src2), subreg_hireg))))>;

// Multiply 64-bit signed and use upper result.
def : Pat <(mulhs (i64 DoubleRegs:$src1), (i64 DoubleRegs:$src2)),
      (i64
       (M2_dpmpyss_acc_s0
        (i64
         (A2_combinew (A2_tfrsi 0),
          (i32
           (EXTRACT_SUBREG
            (i64
             (S2_lsr_i_p
              (i64
               (M2_dpmpyss_acc_s0
                (i64
                 (M2_dpmpyss_acc_s0
                  (i64
                   (A2_combinew (A2_tfrsi 0),
                    (i32
                     (EXTRACT_SUBREG
                      (i64
                       (S2_lsr_i_p
                        (i64
                         (M2_dpmpyuu_s0 
                           (i32 (EXTRACT_SUBREG (i64 DoubleRegs:$src1),
                                                      subreg_loreg)),
                                 (i32 (EXTRACT_SUBREG (i64 DoubleRegs:$src2),
                                                      subreg_loreg)))), 32)),
                      subreg_loreg)))),
                  (i32 (EXTRACT_SUBREG (i64 DoubleRegs:$src1), subreg_hireg)),
                  (i32 (EXTRACT_SUBREG (i64 DoubleRegs:$src2), subreg_loreg)))),
                (i32 (EXTRACT_SUBREG (i64 DoubleRegs:$src1), subreg_loreg)),
                (i32 (EXTRACT_SUBREG (i64 DoubleRegs:$src2), subreg_hireg)))),
              32)), subreg_loreg)))),
        (i32 (EXTRACT_SUBREG (i64 DoubleRegs:$src1), subreg_hireg)),
        (i32 (EXTRACT_SUBREG (i64 DoubleRegs:$src2), subreg_hireg))))>;

// Hexagon specific ISD nodes.
//def SDTHexagonADJDYNALLOC : SDTypeProfile<1, 2, [SDTCisSameAs<0, 1>]>;
def SDTHexagonADJDYNALLOC : SDTypeProfile<1, 2,
                                  [SDTCisVT<0, i32>, SDTCisVT<1, i32>]>;
def Hexagon_ADJDYNALLOC : SDNode<"HexagonISD::ADJDYNALLOC",
                                  SDTHexagonADJDYNALLOC>;
// Needed to tag these instructions for stack layout.
let usesCustomInserter = 1 in
def ADJDYNALLOC : ALU32_ri<(outs IntRegs:$dst), (ins IntRegs:$src1,
                                                     s16Imm:$src2),
                  "$dst = add($src1, #$src2)",
                  [(set (i32 IntRegs:$dst),
                        (Hexagon_ADJDYNALLOC (i32 IntRegs:$src1),
                                             s16ImmPred:$src2))]>;

def SDTHexagonARGEXTEND : SDTypeProfile<1, 1, [SDTCisVT<0, i32>]>;
def Hexagon_ARGEXTEND : SDNode<"HexagonISD::ARGEXTEND", SDTHexagonARGEXTEND>;
def ARGEXTEND : ALU32_rr <(outs IntRegs:$dst), (ins IntRegs:$src1),
                "$dst = $src1",
                [(set (i32 IntRegs:$dst),
                      (Hexagon_ARGEXTEND (i32 IntRegs:$src1)))]>;

let AddedComplexity = 100 in
def : Pat<(i32 (sext_inreg (Hexagon_ARGEXTEND (i32 IntRegs:$src1)), i16)),
      (COPY (i32 IntRegs:$src1))>;

def HexagonWrapperJT: SDNode<"HexagonISD::WrapperJT", SDTIntUnaryOp>;

def : Pat<(HexagonWrapperJT tjumptable:$dst),
          (i32 (CONST32_set_jt tjumptable:$dst))>;

// XTYPE/SHIFT

// Multi-class for logical operators :
// Shift by immediate/register and accumulate/logical
multiclass xtype_imm<string OpcStr, SDNode OpNode1, SDNode OpNode2> {
  def _ri : SInst_acc<(outs IntRegs:$dst),
            (ins IntRegs:$src1, IntRegs:$src2, u5Imm:$src3),
            !strconcat("$dst ", !strconcat(OpcStr, "($src2, #$src3)")),
            [(set (i32 IntRegs:$dst),
                  (OpNode2 (i32 IntRegs:$src1),
                           (OpNode1 (i32 IntRegs:$src2),
                                    u5ImmPred:$src3)))],
            "$src1 = $dst">;

  def d_ri : SInst_acc<(outs DoubleRegs:$dst),
            (ins DoubleRegs:$src1, DoubleRegs:$src2, u6Imm:$src3),
            !strconcat("$dst ", !strconcat(OpcStr, "($src2, #$src3)")),
            [(set (i64 DoubleRegs:$dst), (OpNode2 (i64 DoubleRegs:$src1),
                          (OpNode1 (i64 DoubleRegs:$src2), u6ImmPred:$src3)))],
            "$src1 = $dst">;
}

// Multi-class for logical operators :
// Shift by register and accumulate/logical (32/64 bits)
multiclass xtype_reg<string OpcStr, SDNode OpNode1, SDNode OpNode2> {
  def _rr : SInst_acc<(outs IntRegs:$dst),
            (ins IntRegs:$src1, IntRegs:$src2, IntRegs:$src3),
            !strconcat("$dst ", !strconcat(OpcStr, "($src2, $src3)")),
            [(set (i32 IntRegs:$dst),
                  (OpNode2 (i32 IntRegs:$src1),
                           (OpNode1 (i32 IntRegs:$src2),
                                    (i32 IntRegs:$src3))))],
            "$src1 = $dst">;

  def d_rr : SInst_acc<(outs DoubleRegs:$dst),
            (ins DoubleRegs:$src1, DoubleRegs:$src2, IntRegs:$src3),
            !strconcat("$dst ", !strconcat(OpcStr, "($src2, $src3)")),
            [(set (i64 DoubleRegs:$dst),
                  (OpNode2 (i64 DoubleRegs:$src1),
                           (OpNode1 (i64 DoubleRegs:$src2),
                                    (i32 IntRegs:$src3))))],
            "$src1 = $dst">;

}

multiclass basic_xtype_imm<string OpcStr, SDNode OpNode> {
let AddedComplexity = 100 in
  defm _ADD : xtype_imm< !strconcat("+= ", OpcStr), OpNode, add>;
  defm _SUB : xtype_imm< !strconcat("-= ", OpcStr), OpNode, sub>;
  defm _AND : xtype_imm< !strconcat("&= ", OpcStr), OpNode, and>;
  defm _OR  : xtype_imm< !strconcat("|= ", OpcStr), OpNode, or>;
}

multiclass basic_xtype_reg<string OpcStr, SDNode OpNode> {
let AddedComplexity = 100 in
  defm _ADD : xtype_reg< !strconcat("+= ", OpcStr), OpNode, add>;
  defm _SUB : xtype_reg< !strconcat("-= ", OpcStr), OpNode, sub>;
  defm _AND : xtype_reg< !strconcat("&= ", OpcStr), OpNode, and>;
  defm _OR  : xtype_reg< !strconcat("|= ", OpcStr), OpNode, or>;
}

multiclass xtype_xor_imm<string OpcStr, SDNode OpNode> {
let AddedComplexity = 100 in
  defm _XOR : xtype_imm< !strconcat("^= ", OpcStr), OpNode, xor>;
}

defm ASL : basic_xtype_imm<"asl", shl>, basic_xtype_reg<"asl", shl>,
           xtype_xor_imm<"asl", shl>;

defm LSR : basic_xtype_imm<"lsr", srl>, basic_xtype_reg<"lsr", srl>,
           xtype_xor_imm<"lsr", srl>;

defm ASR : basic_xtype_imm<"asr", sra>, basic_xtype_reg<"asr", sra>;
defm LSL : basic_xtype_reg<"lsl", shl>;

// Change the sign of the immediate for Rd=-mpyi(Rs,#u8)
def : Pat <(mul (i32 IntRegs:$src1), (ineg n8ImmPred:$src2)),
      (i32 (M2_mpysin (i32 IntRegs:$src1), u8ImmPred:$src2))>;

//===----------------------------------------------------------------------===//
// V3 Instructions +
//===----------------------------------------------------------------------===//

include "HexagonInstrInfoV3.td"

//===----------------------------------------------------------------------===//
// V3 Instructions -
//===----------------------------------------------------------------------===//

//===----------------------------------------------------------------------===//
// V4 Instructions +
//===----------------------------------------------------------------------===//

include "HexagonInstrInfoV4.td"

//===----------------------------------------------------------------------===//
// V4 Instructions -
//===----------------------------------------------------------------------===//

//===----------------------------------------------------------------------===//
// V5 Instructions +
//===----------------------------------------------------------------------===//

include "HexagonInstrInfoV5.td"

//===----------------------------------------------------------------------===//
// V5 Instructions -
//===----------------------------------------------------------------------===//
